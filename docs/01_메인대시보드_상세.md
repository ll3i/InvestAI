# 📊 Pixie 메인 대시보드 개발 문서

## 🎯 페이지 개요

### 목적
투자자에게 종합적인 투자 현황과 시장 정보를 제공하는 중앙 허브 역할을 하는 메인 대시보드입니다.

### 주요 기능
- 실시간 시장 현황 표시
- 개인 포트폴리오 요약
- AI 투자 추천
- 최신 뉴스 및 이슈
- 빠른 액세스 메뉴

## 🏗️ 기술적 아키텍처

### 프론트엔드 구조
```
web/templates/
├── dashboard.html          # 메인 대시보드 템플릿
├── layout.html            # 공통 레이아웃
└── index.html             # 랜딩 페이지
```

### 백엔드 구조
```
web/
├── app.py                 # 메인 Flask 애플리케이션
├── blueprints/           # 모듈화된 라우트
│   ├── auth/            # 인증 관련
│   ├── stock/           # 주식 데이터
│   └── news/            # 뉴스 데이터
└── services/            # 비즈니스 로직
    ├── database_service.py
    └── alert_service.py
```

## 📱 UI/UX 설계

### 레이아웃 구성
1. **헤더 영역**
   - 로고 및 네비게이션
   - 사용자 프로필 및 알림
   - 검색 기능

2. **메인 콘텐츠 영역**
   - 시장 현황 카드
   - 포트폴리오 요약
   - AI 추천 섹션
   - 최신 뉴스 피드

3. **사이드바**
   - 빠른 액세스 메뉴
   - 관심 종목 목록
   - 학습 진도 표시

### 반응형 디자인
- **데스크톱**: 3열 그리드 레이아웃
- **태블릿**: 2열 그리드 레이아웃  
- **모바일**: 1열 스택 레이아웃

## 🔧 핵심 기능 구현

### 1. 실시간 시장 데이터 표시
```python
# web/app.py - 시장 데이터 API
@app.route('/api/market-summary')
def get_market_summary():
    """실시간 시장 요약 정보 제공"""
    try:
        # KOSPI, KOSDAQ 지수 조회
        kospi_data = get_kospi_index()
        kosdaq_data = get_kosdaq_index()
        
        # 환율 정보
        exchange_rate = get_exchange_rate()
        
        return jsonify({
            'kospi': kospi_data,
            'kosdaq': kosdaq_data,
            'exchange_rate': exchange_rate,
            'timestamp': datetime.now().isoformat()
        })
    except Exception as e:
        logger.error(f"시장 데이터 조회 실패: {e}")
        return jsonify({'error': '데이터 조회 실패'}), 500
```

### 2. 포트폴리오 요약
```python
# web/services/portfolio_service.py
class PortfolioService:
    def get_portfolio_summary(self, user_id: str) -> Dict[str, Any]:
        """사용자 포트폴리오 요약 정보"""
        try:
            # 보유 종목 조회
            holdings = self.get_user_holdings(user_id)
            
            # 총 자산 계산
            total_value = sum(holding['current_value'] for holding in holdings)
            
            # 수익률 계산
            total_profit = sum(holding['profit_loss'] for holding in holdings)
            profit_rate = (total_profit / (total_value - total_profit)) * 100 if total_value > total_profit else 0
            
            return {
                'total_value': total_value,
                'total_profit': total_profit,
                'profit_rate': profit_rate,
                'holdings_count': len(holdings),
                'top_holdings': sorted(holdings, key=lambda x: x['current_value'], reverse=True)[:5]
            }
        except Exception as e:
            logger.error(f"포트폴리오 요약 조회 실패: {e}")
            return {}
```

### 3. AI 투자 추천
```python
# web/services/ai_recommendation_service.py
class AIRecommendationService:
    def get_daily_recommendations(self, user_profile: Dict[str, Any]) -> List[Dict[str, Any]]:
        """AI 기반 일일 투자 추천"""
        try:
            # 사용자 프로필 분석
            risk_tolerance = user_profile.get('risk_tolerance', 50)
            investment_style = user_profile.get('investment_style', 'balanced')
            
            # 시장 데이터 분석
            market_analysis = self.analyze_market_conditions()
            
            # 추천 종목 생성
            recommendations = self.generate_recommendations(
                risk_tolerance=risk_tolerance,
                investment_style=investment_style,
                market_analysis=market_analysis
            )
            
            return recommendations[:5]  # 상위 5개 추천
            
        except Exception as e:
            logger.error(f"AI 추천 생성 실패: {e}")
            return []
```

## 📊 데이터베이스 구조

### 사용자 포트폴리오 테이블
```sql
CREATE TABLE user_portfolio (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    ticker VARCHAR(10) NOT NULL,
    quantity INTEGER NOT NULL,
    average_price DECIMAL(10,2) NOT NULL,
    purchase_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 시장 데이터 테이블
```sql
CREATE TABLE market_data (
    id SERIAL PRIMARY KEY,
    ticker VARCHAR(10) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    volume BIGINT NOT NULL,
    change_rate DECIMAL(5,2),
    market_cap BIGINT,
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 🔄 실시간 업데이트 시스템

### WebSocket 연결
```javascript
// web/static/js/dashboard.js
class DashboardWebSocket {
    constructor() {
        this.socket = new WebSocket('ws://localhost:5000/ws/dashboard');
        this.setupEventListeners();
    }
    
    setupEventListeners() {
        this.socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.updateDashboard(data);
        };
        
        this.socket.onerror = (error) => {
            console.error('WebSocket 오류:', error);
            this.fallbackToPolling();
        };
    }
    
    updateDashboard(data) {
        // 시장 데이터 업데이트
        if (data.market_data) {
            this.updateMarketIndices(data.market_data);
        }
        
        // 포트폴리오 업데이트
        if (data.portfolio) {
            this.updatePortfolioSummary(data.portfolio);
        }
        
        // 뉴스 업데이트
        if (data.news) {
            this.updateNewsFeed(data.news);
        }
    }
}
```

### 폴링 시스템 (Fallback)
```javascript
// 실시간 업데이트 폴링
setInterval(() => {
    fetch('/api/dashboard-update')
        .then(response => response.json())
        .then(data => {
            this.updateDashboard(data);
        })
        .catch(error => {
            console.error('대시보드 업데이트 실패:', error);
        });
}, 30000); // 30초마다 업데이트
```

## 🎨 CSS 스타일링

### 메인 대시보드 스타일
```css
/* web/static/css/dashboard.css */
.dashboard-container {
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 20px;
    padding: 20px;
    max-width: 1400px;
    margin: 0 auto;
}

.market-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
    margin-bottom: 30px;
}

.market-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    transition: transform 0.3s ease;
}

.market-card:hover {
    transform: translateY(-5px);
}

.portfolio-summary {
    background: white;
    border-radius: 12px;
    padding: 25px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    margin-bottom: 30px;
}

.ai-recommendations {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
    border-radius: 12px;
    padding: 25px;
    margin-bottom: 30px;
}

.news-feed {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

/* 반응형 디자인 */
@media (max-width: 768px) {
    .dashboard-container {
        grid-template-columns: 1fr;
    }
    
    .market-summary {
        grid-template-columns: 1fr;
    }
}
```

## 🔐 보안 및 인증

### 사용자 인증
```python
# web/blueprints/auth/routes.py
from functools import wraps
from flask import session, redirect, url_for

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return redirect(url_for('auth.login'))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/dashboard')
@login_required
def dashboard():
    """인증된 사용자만 접근 가능한 대시보드"""
    user_id = session['user_id']
    user_profile = get_user_profile(user_id)
    return render_template('dashboard.html', user=user_profile)
```

### 데이터 보안
```python
# web/services/security_service.py
class SecurityService:
    def sanitize_user_input(self, data: str) -> str:
        """사용자 입력 데이터 정제"""
        import html
        return html.escape(data.strip())
    
    def validate_user_permission(self, user_id: str, resource_id: str) -> bool:
        """사용자 권한 검증"""
        user_permissions = self.get_user_permissions(user_id)
        return resource_id in user_permissions
    
    def encrypt_sensitive_data(self, data: str) -> str:
        """민감한 데이터 암호화"""
        from cryptography.fernet import Fernet
        key = os.environ.get('ENCRYPTION_KEY')
        f = Fernet(key)
        return f.encrypt(data.encode()).decode()
```

## 📈 성능 최적화

### 캐싱 전략
```python
# web/services/cache_service.py
from functools import lru_cache
import redis

class CacheService:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
    
    @lru_cache(maxsize=128)
    def get_market_data(self, ticker: str) -> Dict[str, Any]:
        """시장 데이터 캐싱"""
        cache_key = f"market_data:{ticker}"
        cached_data = self.redis_client.get(cache_key)
        
        if cached_data:
            return json.loads(cached_data)
        
        # 새로운 데이터 조회
        fresh_data = self.fetch_market_data(ticker)
        self.redis_client.setex(cache_key, 300, json.dumps(fresh_data))  # 5분 캐시
        return fresh_data
    
    def invalidate_cache(self, pattern: str):
        """캐시 무효화"""
        keys = self.redis_client.keys(pattern)
        if keys:
            self.redis_client.delete(*keys)
```

### 데이터베이스 최적화
```sql
-- 인덱스 생성
CREATE INDEX idx_user_portfolio_user_id ON user_portfolio(user_id);
CREATE INDEX idx_market_data_ticker ON market_data(ticker);
CREATE INDEX idx_market_data_recorded_at ON market_data(recorded_at);

-- 파티셔닝 (대용량 데이터)
CREATE TABLE market_data_2024 PARTITION OF market_data
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

## 🧪 테스트 전략

### 단위 테스트
```python
# tests/test_dashboard.py
import pytest
from web.services.portfolio_service import PortfolioService

class TestPortfolioService:
    def test_get_portfolio_summary(self):
        """포트폴리오 요약 테스트"""
        service = PortfolioService()
        user_id = "test_user_123"
        
        result = service.get_portfolio_summary(user_id)
        
        assert 'total_value' in result
        assert 'total_profit' in result
        assert 'profit_rate' in result
        assert isinstance(result['total_value'], (int, float))
        assert isinstance(result['profit_rate'], (int, float))
    
    def test_empty_portfolio(self):
        """빈 포트폴리오 테스트"""
        service = PortfolioService()
        user_id = "empty_user"
        
        result = service.get_portfolio_summary(user_id)
        
        assert result['total_value'] == 0
        assert result['total_profit'] == 0
        assert result['holdings_count'] == 0
```

### 통합 테스트
```python
# tests/test_dashboard_integration.py
class TestDashboardIntegration:
    def test_dashboard_page_load(self, client):
        """대시보드 페이지 로드 테스트"""
        response = client.get('/dashboard')
        assert response.status_code == 200
        assert b'portfolio-summary' in response.data
    
    def test_market_data_api(self, client):
        """시장 데이터 API 테스트"""
        response = client.get('/api/market-summary')
        assert response.status_code == 200
        
        data = response.get_json()
        assert 'kospi' in data
        assert 'kosdaq' in data
        assert 'exchange_rate' in data
```

## 🚀 배포 및 운영

### 환경 설정
```python
# web/config.py
class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key'
    DATABASE_URL = os.environ.get('DATABASE_URL')
    REDIS_URL = os.environ.get('REDIS_URL')
    
    # API 설정
    OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY')
    STOCK_API_KEY = os.environ.get('STOCK_API_KEY')
    
    # 캐시 설정
    CACHE_TYPE = "redis"
    CACHE_REDIS_URL = os.environ.get('REDIS_URL')
    CACHE_DEFAULT_TIMEOUT = 300

class DevelopmentConfig(Config):
    DEBUG = True
    TESTING = False

class ProductionConfig(Config):
    DEBUG = False
    TESTING = False
```

### 모니터링
```python
# web/services/monitoring_service.py
import logging
from datetime import datetime

class MonitoringService:
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def log_dashboard_access(self, user_id: str, access_time: datetime):
        """대시보드 접근 로깅"""
        self.logger.info(f"Dashboard accessed by user {user_id} at {access_time}")
    
    def log_performance_metrics(self, endpoint: str, response_time: float):
        """성능 메트릭 로깅"""
        self.logger.info(f"Endpoint {endpoint} response time: {response_time}ms")
    
    def alert_error(self, error: Exception, context: str):
        """에러 알림"""
        self.logger.error(f"Error in {context}: {str(error)}")
        # 슬랙/이메일 알림 발송
```

## 📊 분석 및 개선

### 사용자 행동 분석
```python
# web/services/analytics_service.py
class AnalyticsService:
    def track_user_behavior(self, user_id: str, action: str, data: Dict[str, Any]):
        """사용자 행동 추적"""
        event = {
            'user_id': user_id,
            'action': action,
            'data': data,
            'timestamp': datetime.now().isoformat(),
            'session_id': session.get('session_id')
        }
        
        # 이벤트 저장
        self.save_user_event(event)
    
    def get_dashboard_metrics(self) -> Dict[str, Any]:
        """대시보드 사용 통계"""
        return {
            'daily_active_users': self.get_daily_active_users(),
            'average_session_duration': self.get_avg_session_duration(),
            'most_viewed_sections': self.get_most_viewed_sections(),
            'user_engagement_score': self.calculate_engagement_score()
        }
```

### A/B 테스트
```python
# web/services/ab_testing_service.py
class ABTestingService:
    def get_dashboard_variant(self, user_id: str) -> str:
        """사용자별 대시보드 변형 결정"""
        user_hash = hash(user_id) % 100
        
        if user_hash < 50:
            return 'control'  # 기존 레이아웃
        else:
            return 'variant'  # 새로운 레이아웃
    
    def track_variant_performance(self, user_id: str, variant: str, metric: str, value: float):
        """변형 성능 추적"""
        self.save_variant_metric(user_id, variant, metric, value)
```

## 🔄 향후 개선 계획

### 단기 개선사항 (1-2개월)
1. **실시간 알림 시스템** 구현
2. **개인화된 위젯** 추가
3. **다크 모드** 지원
4. **모바일 앱** 개발

### 중기 개선사항 (3-6개월)
1. **AI 기반 포트폴리오 최적화** 기능
2. **소셜 투자** 기능 추가
3. **고급 차트** 라이브러리 통합
4. **멀티 언어** 지원

### 장기 개선사항 (6개월 이상)
1. **블록체인 기반** 투자 기록
2. **AR/VR** 투자 시각화
3. **음성 인터페이스** 추가
4. **국제 시장** 확장

## 📚 참고 자료

### 기술 스택
- **프론트엔드**: HTML5, CSS3, JavaScript (ES6+)
- **백엔드**: Python Flask
- **데이터베이스**: PostgreSQL, Redis
- **AI/ML**: OpenAI API, TensorFlow
- **배포**: Docker, AWS/GCP

### 라이브러리 및 도구
- **차트**: Chart.js, D3.js
- **UI 프레임워크**: Bootstrap 5
- **실시간 통신**: WebSocket, Socket.IO
- **테스트**: pytest, Selenium
- **모니터링**: Prometheus, Grafana

이 문서는 Pixie 투자챗봇의 메인 대시보드 개발 과정과 기술적 세부사항을 상세히 다루고 있습니다. 지속적인 업데이트와 개선을 통해 사용자 경험을 향상시키는 것이 목표입니다. 