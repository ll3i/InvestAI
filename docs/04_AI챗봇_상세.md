# 🤖 Pixie AI 챗봇 페이지 개발 문서

## 🎯 페이지 개요

### 목적
투자자에게 개인화된 투자 상담과 실시간 질의응답을 제공하는 AI 기반 챗봇 시스템입니다.

### 주요 기능
- 다중 AI 에이전트 시스템 (AI-A → AI-A2 → AI-B → Final)
- 실시간 투자 상담
- 개인화된 포트폴리오 분석
- 시장 동향 분석
- 자연어 대화 인터페이스

## 🏗️ 기술적 아키텍처

### 프론트엔드 구조
```
web/templates/
├── chatbot.html              # 메인 챗봇 페이지
├── chatbot_widget.html       # 챗봇 위젯
└── chatbot_history.html      # 대화 기록 페이지
```

### 백엔드 구조
```
web/
├── app.py                     # 챗봇 관련 라우트
├── blueprints/
│   └── chat/                 # 챗봇 관련 라우트
└── services/
    ├── ai_chat_service.py    # AI 챗봇 서비스
    ├── conversation_service.py # 대화 관리
    └── memory_service.py     # 대화 메모리 관리
```

## 📱 UI/UX 설계

### 챗봇 인터페이스
1. **대화창 레이아웃**
   - 사용자 메시지 (오른쪽)
   - AI 응답 (왼쪽)
   - 시스템 메시지 (중앙)

2. **입력 영역**
   - 텍스트 입력창
   - 음성 입력 버튼
   - 파일 첨부 기능

3. **기능 버튼**
   - 포트폴리오 분석
   - 시장 동향 조회
   - 투자 추천 요청

### 반응형 디자인
```css
/* web/static/css/chatbot.css */
.chatbot-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    max-width: 800px;
    margin: 0 auto;
    background: #f8f9fa;
}

.chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message {
    display: flex;
    align-items: flex-start;
    gap: 10px;
    animation: fadeIn 0.3s ease-in;
}

.message.user {
    flex-direction: row-reverse;
}

.message-content {
    max-width: 70%;
    padding: 12px 16px;
    border-radius: 18px;
    word-wrap: break-word;
}

.message.user .message-content {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border-bottom-right-radius: 4px;
}

.message.ai .message-content {
    background: white;
    color: #333;
    border: 1px solid #e9ecef;
    border-bottom-left-radius: 4px;
}

.chat-input {
    padding: 20px;
    background: white;
    border-top: 1px solid #e9ecef;
    display: flex;
    gap: 10px;
    align-items: center;
}

.input-field {
    flex: 1;
    padding: 12px 16px;
    border: 2px solid #e9ecef;
    border-radius: 25px;
    outline: none;
    transition: border-color 0.3s ease;
}

.input-field:focus {
    border-color: #667eea;
}

.send-button {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 12px 20px;
    border-radius: 25px;
    cursor: pointer;
    transition: transform 0.2s ease;
}

.send-button:hover {
    transform: translateY(-2px);
}

/* 타이핑 애니메이션 */
.typing-indicator {
    display: flex;
    gap: 4px;
    padding: 12px 16px;
    background: white;
    border-radius: 18px;
    border-bottom-left-radius: 4px;
    max-width: 60px;
}

.typing-dot {
    width: 8px;
    height: 8px;
    background: #667eea;
    border-radius: 50%;
    animation: typing 1.4s infinite ease-in-out;
}

.typing-dot:nth-child(1) { animation-delay: -0.32s; }
.typing-dot:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
    0%, 80%, 100% { transform: scale(0); }
    40% { transform: scale(1); }
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}
```

## 🔧 핵심 기능 구현

### 1. 다중 AI 에이전트 시스템
```python
# web/services/ai_chat_service.py
class AIChatService:
    def __init__(self):
        self.openai_client = OpenAI(api_key=os.environ.get('OPENAI_API_KEY'))
        self.conversation_memory = {}
        self.user_profiles = {}
    
    def process_chat_message(self, user_id: str, message: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """다중 AI 에이전트를 통한 메시지 처리"""
        try:
            # 1단계: AI-A 초기 분석
            ai_a_response = self.generate_ai_a_response(message, context)
            
            # 2단계: AI-A2 질문 정제
            ai_a2_response = self.generate_ai_a2_response(message, ai_a_response, context)
            
            # 3단계: AI-B 데이터 분석
            ai_b_response = self.generate_ai_b_response(ai_a2_response, context)
            
            # 4단계: 최종 응답 생성
            final_response = self.generate_final_response(
                original_message=message,
                ai_a_response=ai_a_response,
                ai_a2_response=ai_a2_response,
                ai_b_response=ai_b_response,
                context=context
            )
            
            # 대화 기록 저장
            self.save_conversation(user_id, message, final_response)
            
            return {
                'response': final_response,
                'confidence': self.calculate_confidence(final_response),
                'suggestions': self.generate_suggestions(context),
                'analysis': {
                    'ai_a': ai_a_response,
                    'ai_a2': ai_a2_response,
                    'ai_b': ai_b_response
                }
            }
            
        except Exception as e:
            logger.error(f"AI 챗봇 처리 실패: {e}")
            return {
                'response': "죄송합니다. 일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요.",
                'error': True
            }
    
    def generate_ai_a_response(self, message: str, context: Dict[str, Any]) -> str:
        """AI-A: 초기 사용자 의도 분석"""
        prompt = f"""
        사용자의 투자 관련 질문을 분석하고 초기 응답을 생성하세요.
        
        사용자 메시지: {message}
        사용자 프로필: {context.get('user_profile', {})}
        대화 컨텍스트: {context.get('conversation_history', [])}
        
        다음 형식으로 응답하세요:
        1. 질문 의도 분석
        2. 핵심 키워드 추출
        3. 초기 응답 생성
        """
        
        response = self.openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=500,
            temperature=0.7
        )
        
        return response.choices[0].message.content
    
    def generate_ai_a2_response(self, message: str, ai_a_response: str, context: Dict[str, Any]) -> str:
        """AI-A2: 질문 정제 및 상세 분석"""
        prompt = f"""
        AI-A의 초기 분석을 바탕으로 사용자 질문을 정제하고 상세 분석을 수행하세요.
        
        원본 메시지: {message}
        AI-A 분석: {ai_a_response}
        사용자 프로필: {context.get('user_profile', {})}
        
        다음을 수행하세요:
        1. 질문의 핵심 의도 파악
        2. 필요한 추가 정보 식별
        3. 구체적인 분석 방향 설정
        """
        
        response = self.openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=400,
            temperature=0.6
        )
        
        return response.choices[0].message.content
    
    def generate_ai_b_response(self, ai_a2_response: str, context: Dict[str, Any]) -> str:
        """AI-B: 데이터 기반 분석 및 추천"""
        prompt = f"""
        AI-A2의 분석을 바탕으로 실제 투자 데이터를 활용한 구체적인 분석과 추천을 제공하세요.
        
        AI-A2 분석: {ai_a2_response}
        시장 데이터: {context.get('market_data', {})}
        사용자 포트폴리오: {context.get('user_portfolio', {})}
        
        다음을 포함하여 응답하세요:
        1. 관련 종목 분석
        2. 시장 동향 분석
        3. 구체적인 투자 추천
        4. 위험 요소 고려사항
        """
        
        response = self.openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=600,
            temperature=0.5
        )
        
        return response.choices[0].message.content
    
    def generate_final_response(self, original_message: str, ai_a_response: str, 
                              ai_a2_response: str, ai_b_response: str, context: Dict[str, Any]) -> str:
        """최종 응답 생성"""
        prompt = f"""
        모든 AI 에이전트의 분석을 종합하여 사용자에게 최적화된 최종 응답을 생성하세요.
        
        원본 질문: {original_message}
        AI-A 분석: {ai_a_response}
        AI-A2 정제: {ai_a2_response}
        AI-B 분석: {ai_b_response}
        사용자 프로필: {context.get('user_profile', {})}
        
        다음 형식으로 응답하세요:
        1. 친근하고 이해하기 쉬운 톤
        2. 구체적인 데이터와 예시 포함
        3. 실용적인 조언 제공
        4. 추가 질문 유도
        """
        
        response = self.openai_client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=800,
            temperature=0.7
        )
        
        return response.choices[0].message.content
```

### 2. 대화 메모리 관리
```python
# web/services/memory_service.py
class MemoryService:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
    
    def save_conversation(self, user_id: str, message: str, response: str):
        """대화 기록 저장"""
        try:
            conversation_key = f"conversation:{user_id}"
            
            # 기존 대화 기록 조회
            existing_conversation = self.redis_client.get(conversation_key)
            conversation = json.loads(existing_conversation) if existing_conversation else []
            
            # 새로운 대화 추가
            conversation.append({
                'timestamp': datetime.now().isoformat(),
                'user_message': message,
                'ai_response': response,
                'message_id': str(uuid.uuid4())
            })
            
            # 최근 50개 대화만 유지
            if len(conversation) > 50:
                conversation = conversation[-50:]
            
            # Redis에 저장 (24시간 만료)
            self.redis_client.setex(conversation_key, 86400, json.dumps(conversation))
            
        except Exception as e:
            logger.error(f"대화 기록 저장 실패: {e}")
    
    def get_conversation_history(self, user_id: str, limit: int = 10) -> List[Dict[str, Any]]:
        """대화 기록 조회"""
        try:
            conversation_key = f"conversation:{user_id}"
            conversation_data = self.redis_client.get(conversation_key)
            
            if conversation_data:
                conversation = json.loads(conversation_data)
                return conversation[-limit:] if limit else conversation
            
            return []
            
        except Exception as e:
            logger.error(f"대화 기록 조회 실패: {e}")
            return []
    
    def get_user_context(self, user_id: str) -> Dict[str, Any]:
        """사용자 컨텍스트 조회"""
        try:
            # 최근 대화 기록
            recent_conversations = self.get_conversation_history(user_id, 5)
            
            # 사용자 프로필
            user_profile = self.get_user_profile(user_id)
            
            # 시장 데이터
            market_data = self.get_current_market_data()
            
            return {
                'conversation_history': recent_conversations,
                'user_profile': user_profile,
                'market_data': market_data,
                'session_info': {
                    'user_id': user_id,
                    'session_start': datetime.now().isoformat()
                }
            }
            
        except Exception as e:
            logger.error(f"사용자 컨텍스트 조회 실패: {e}")
            return {}
```

### 3. 실시간 챗봇 인터페이스
```javascript
// web/static/js/chatbot.js
class ChatbotManager {
    constructor() {
        this.messages = [];
        this.isTyping = false;
        this.userId = this.getUserId();
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.loadChatHistory();
        this.showWelcomeMessage();
    }
    
    setupEventListeners() {
        const inputField = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        
        inputField.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage();
            }
        });
        
        sendButton.addEventListener('click', () => {
            this.sendMessage();
        });
        
        // 음성 입력 버튼
        const voiceButton = document.getElementById('voice-button');
        if (voiceButton) {
            voiceButton.addEventListener('click', () => {
                this.startVoiceInput();
            });
        }
    }
    
    async sendMessage() {
        const inputField = document.getElementById('chat-input');
        const message = inputField.value.trim();
        
        if (!message || this.isTyping) return;
        
        // 사용자 메시지 표시
        this.addMessage(message, 'user');
        inputField.value = '';
        
        // 타이핑 표시
        this.showTypingIndicator();
        
        try {
            // AI 응답 요청
            const response = await fetch('/api/chat/send', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message: message,
                    user_id: this.userId
                })
            });
            
            const data = await response.json();
            
            // 타이핑 표시 제거
            this.hideTypingIndicator();
            
            if (data.success) {
                // AI 응답 표시
                this.addMessage(data.response, 'ai');
                
                // 제안사항 표시
                if (data.suggestions && data.suggestions.length > 0) {
                    this.showSuggestions(data.suggestions);
                }
            } else {
                this.addMessage("죄송합니다. 일시적인 오류가 발생했습니다.", 'ai');
            }
            
        } catch (error) {
            console.error('메시지 전송 실패:', error);
            this.hideTypingIndicator();
            this.addMessage("네트워크 오류가 발생했습니다. 다시 시도해주세요.", 'ai');
        }
    }
    
    addMessage(content, sender) {
        const messagesContainer = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${sender}`;
        
        const avatar = document.createElement('div');
        avatar.className = 'message-avatar';
        avatar.innerHTML = sender === 'user' ? '👤' : '🤖';
        
        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';
        messageContent.innerHTML = this.formatMessage(content);
        
        messageDiv.appendChild(avatar);
        messageDiv.appendChild(messageContent);
        
        messagesContainer.appendChild(messageDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
        // 메시지 저장
        this.messages.push({
            sender: sender,
            content: content,
            timestamp: new Date().toISOString()
        });
    }
    
    formatMessage(content) {
        // 마크다운 형식 지원
        return marked.parse(content);
    }
    
    showTypingIndicator() {
        this.isTyping = true;
        const messagesContainer = document.getElementById('chat-messages');
        const typingDiv = document.createElement('div');
        typingDiv.className = 'message ai typing-indicator-container';
        typingDiv.id = 'typing-indicator';
        
        typingDiv.innerHTML = `
            <div class="message-avatar">🤖</div>
            <div class="typing-indicator">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        `;
        
        messagesContainer.appendChild(typingDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    hideTypingIndicator() {
        this.isTyping = false;
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) {
            typingIndicator.remove();
        }
    }
    
    showSuggestions(suggestions) {
        const suggestionsContainer = document.createElement('div');
        suggestionsContainer.className = 'suggestions-container';
        
        suggestions.forEach(suggestion => {
            const button = document.createElement('button');
            button.className = 'suggestion-button';
            button.textContent = suggestion;
            button.addEventListener('click', () => {
                document.getElementById('chat-input').value = suggestion;
                this.sendMessage();
            });
            suggestionsContainer.appendChild(button);
        });
        
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.appendChild(suggestionsContainer);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    async loadChatHistory() {
        try {
            const response = await fetch(`/api/chat/history?user_id=${this.userId}`);
            const history = await response.json();
            
            if (history.success && history.messages) {
                history.messages.forEach(msg => {
                    this.addMessage(msg.content, msg.sender);
                });
            }
        } catch (error) {
            console.error('채팅 기록 로드 실패:', error);
        }
    }
    
    showWelcomeMessage() {
        const welcomeMessage = `
안녕하세요! Pixie AI 투자 상담사입니다. 👋

저는 다음과 같은 도움을 드릴 수 있습니다:

📊 **포트폴리오 분석**
- 현재 보유 종목 분석
- 투자 성과 평가
- 리밸런싱 추천

📈 **시장 동향 분석**
- 실시간 시장 정보
- 섹터별 동향 분석
- 투자 기회 탐색

💡 **투자 상담**
- 개인화된 투자 전략
- 위험 관리 조언
- 투자 교육 자료

무엇을 도와드릴까요?
        `;
        
        this.addMessage(welcomeMessage, 'ai');
    }
}
```

## 📊 데이터베이스 구조

### 챗봇 관련 테이블
```sql
CREATE TABLE chat_conversations (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    session_id VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE chat_messages (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER REFERENCES chat_conversations(id),
    sender VARCHAR(10) NOT NULL, -- 'user' or 'ai'
    content TEXT NOT NULL,
    message_type VARCHAR(20) DEFAULT 'text', -- 'text', 'image', 'file'
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ai_analysis_logs (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    original_message TEXT NOT NULL,
    ai_a_response TEXT,
    ai_a2_response TEXT,
    ai_b_response TEXT,
    final_response TEXT NOT NULL,
    processing_time DECIMAL(10,3),
    confidence_score DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE user_chat_preferences (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) UNIQUE NOT NULL,
    preferred_language VARCHAR(10) DEFAULT 'ko',
    response_style VARCHAR(20) DEFAULT 'friendly',
    detail_level VARCHAR(20) DEFAULT 'moderate',
    notification_enabled BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 🔄 실시간 통신

### WebSocket 연결
```python
# web/services/websocket_service.py
from flask_socketio import SocketIO, emit, join_room, leave_room

class WebSocketService:
    def __init__(self, socketio):
        self.socketio = socketio
        self.setup_handlers()
    
    def setup_handlers(self):
        @self.socketio.on('connect')
        def handle_connect():
            print('Client connected')
            emit('connected', {'data': 'Connected'})
        
        @self.socketio.on('join')
        def handle_join(data):
            room = data['room']
            join_room(room)
            emit('status', {'msg': f'Joined room: {room}'}, room=room)
        
        @self.socketio.on('chat_message')
        def handle_chat_message(data):
            user_id = data['user_id']
            message = data['message']
            
            # AI 처리
            ai_service = AIChatService()
            context = self.get_user_context(user_id)
            response = ai_service.process_chat_message(user_id, message, context)
            
            # 실시간 응답 전송
            emit('ai_response', {
                'response': response['response'],
                'suggestions': response.get('suggestions', []),
                'timestamp': datetime.now().isoformat()
            }, room=user_id)
```

## 🔐 보안 및 개인정보 보호

### 대화 데이터 암호화
```python
# web/services/chat_security_service.py
class ChatSecurityService:
    def __init__(self):
        self.encryption_key = os.environ.get('CHAT_ENCRYPTION_KEY')
    
    def encrypt_message(self, message: str) -> str:
        """메시지 암호화"""
        from cryptography.fernet import Fernet
        f = Fernet(self.encryption_key)
        return f.encrypt(message.encode()).decode()
    
    def decrypt_message(self, encrypted_message: str) -> str:
        """메시지 복호화"""
        from cryptography.fernet import Fernet
        f = Fernet(self.encryption_key)
        return f.decrypt(encrypted_message.encode()).decode()
    
    def sanitize_user_input(self, message: str) -> str:
        """사용자 입력 정제"""
        import html
        # HTML 태그 제거
        message = html.escape(message)
        # 스크립트 태그 제거
        message = message.replace('<script>', '').replace('</script>', '')
        return message.strip()
    
    def validate_message_length(self, message: str) -> bool:
        """메시지 길이 검증"""
        return len(message) <= 1000  # 최대 1000자
```

## 📈 성능 최적화

### 응답 캐싱
```python
# web/services/chat_cache_service.py
class ChatCacheService:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
    
    def cache_ai_response(self, message_hash: str, response: Dict[str, Any]):
        """AI 응답 캐싱"""
        cache_key = f"ai_response:{message_hash}"
        self.redis_client.setex(cache_key, 3600, json.dumps(response))  # 1시간
    
    def get_cached_response(self, message_hash: str) -> Optional[Dict[str, Any]]:
        """캐시된 응답 조회"""
        cache_key = f"ai_response:{message_hash}"
        cached_data = self.redis_client.get(cache_key)
        return json.loads(cached_data) if cached_data else None
    
    def generate_message_hash(self, message: str, user_context: Dict[str, Any]) -> str:
        """메시지 해시 생성"""
        import hashlib
        context_str = json.dumps(user_context, sort_keys=True)
        return hashlib.md5(f"{message}{context_str}".encode()).hexdigest()
```

## 🧪 테스트 전략

### 단위 테스트
```python
# tests/test_ai_chat_service.py
import pytest
from web.services.ai_chat_service import AIChatService

class TestAIChatService:
    def test_process_chat_message(self):
        """챗봇 메시지 처리 테스트"""
        service = AIChatService()
        user_id = "test_user_123"
        message = "삼성전자 주식에 투자하고 싶은데 어떻게 생각하세요?"
        context = {
            'user_profile': {'risk_tolerance': 70},
            'market_data': {'samsung': {'price': 70000}}
        }
        
        result = service.process_chat_message(user_id, message, context)
        
        assert 'response' in result
        assert 'confidence' in result
        assert isinstance(result['response'], str)
        assert len(result['response']) > 0
    
    def test_ai_agent_chain(self):
        """AI 에이전트 체인 테스트"""
        service = AIChatService()
        message = "투자 포트폴리오를 분석해주세요"
        context = {}
        
        # 각 AI 에이전트 응답 테스트
        ai_a_response = service.generate_ai_a_response(message, context)
        assert len(ai_a_response) > 0
        
        ai_a2_response = service.generate_ai_a2_response(message, ai_a_response, context)
        assert len(ai_a2_response) > 0
        
        ai_b_response = service.generate_ai_b_response(ai_a2_response, context)
        assert len(ai_b_response) > 0
```

## 🚀 배포 및 운영

### 환경 설정
```python
# web/config/chatbot_config.py
class ChatbotConfig:
    # AI 모델 설정
    OPENAI_API_KEY = os.environ.get('OPENAI_API_KEY')
    OPENAI_MODEL = "gpt-4o-mini"
    MAX_TOKENS = 1000
    TEMPERATURE = 0.7
    
    # 대화 설정
    MAX_MESSAGE_LENGTH = 1000
    MAX_CONVERSATION_HISTORY = 50
    SESSION_TIMEOUT = 3600  # 1시간
    
    # 캐시 설정
    RESPONSE_CACHE_TTL = 3600  # 1시간
    CONVERSATION_CACHE_TTL = 86400  # 24시간
    
    # 보안 설정
    CHAT_ENCRYPTION_KEY = os.environ.get('CHAT_ENCRYPTION_KEY')
    RATE_LIMIT_PER_MINUTE = 30
```

## 📊 분석 및 개선

### 사용자 상호작용 분석
```python
# web/services/chat_analytics_service.py
class ChatAnalyticsService:
    def analyze_chat_interactions(self) -> Dict[str, Any]:
        """챗봇 상호작용 분석"""
        return {
            'daily_active_users': self.get_daily_active_users(),
            'average_conversation_length': self.get_avg_conversation_length(),
            'popular_topics': self.get_popular_topics(),
            'user_satisfaction': self.calculate_satisfaction_score(),
            'response_time_analysis': self.analyze_response_times()
        }
    
    def get_popular_topics(self) -> List[Dict[str, Any]]:
        """인기 주제 분석"""
        # 최근 7일간의 대화 데이터 분석
        recent_conversations = self.query_recent_conversations(days=7)
        
        topic_counts = {}
        for conv in recent_conversations:
            topics = self.extract_topics(conv['content'])
            for topic in topics:
                topic_counts[topic] = topic_counts.get(topic, 0) + 1
        
        return sorted(topic_counts.items(), key=lambda x: x[1], reverse=True)[:10]
```

## 🔄 향후 개선 계획

### 단기 개선사항 (1-2개월)
1. **음성 인식** 기능 추가
2. **이미지 분석** 기능
3. **다국어 지원** 확대
4. **실시간 번역** 기능

### 중기 개선사항 (3-6개월)
1. **감정 분석** 통합
2. **개인화된 AI 모델** 훈련
3. **멀티모달** 대화 지원
4. **실시간 시장 데이터** 연동

### 장기 개선사항 (6개월 이상)
1. **AR/VR 챗봇** 인터페이스
2. **블록체인 기반** 투자 기록
3. **AI 튜터** 시스템
4. **글로벌 투자** 상담

## 📚 참고 자료

### 기술 스택
- **프론트엔드**: HTML5, CSS3, JavaScript (ES6+)
- **백엔드**: Python Flask
- **AI/ML**: OpenAI GPT-4, TensorFlow
- **데이터베이스**: PostgreSQL, Redis
- **실시간 통신**: WebSocket, Socket.IO

### 라이브러리 및 도구
- **UI 프레임워크**: Bootstrap 5
- **마크다운**: Marked.js
- **음성 인식**: Web Speech API
- **테스트**: pytest, Selenium
- **모니터링**: Prometheus, Grafana

이 문서는 Pixie 투자챗봇의 AI 챗봇 시스템 개발 과정과 기술적 세부사항을 상세히 다루고 있습니다. 지속적인 AI 모델 개선과 사용자 경험 향상을 통해 더욱 정확하고 유용한 투자 상담을 제공하는 것이 목표입니다. 