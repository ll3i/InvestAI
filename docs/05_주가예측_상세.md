# ğŸ“ˆ Pixie ì£¼ê°€ ì˜ˆì¸¡ í˜ì´ì§€ ê°œë°œ ë¬¸ì„œ

## ğŸ¯ í˜ì´ì§€ ê°œìš”

### ëª©ì 
AI ê¸°ë°˜ ê¸°ìˆ ì  ë¶„ì„ê³¼ ë¨¸ì‹ ëŸ¬ë‹ ëª¨ë¸ì„ í™œìš©í•˜ì—¬ ì£¼ê°€ ì˜ˆì¸¡ ë° íˆ¬ì ê¸°íšŒ ë¶„ì„ì„ ì œê³µí•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### ì£¼ìš” ê¸°ëŠ¥
- AI ê¸°ë°˜ ì£¼ê°€ ì˜ˆì¸¡ ëª¨ë¸
- ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„
- ì‹œê³„ì—´ ì˜ˆì¸¡ ì•Œê³ ë¦¬ì¦˜
- ì‹¤ì‹œê°„ ì°¨íŠ¸ ì‹œê°í™”
- íˆ¬ì ì‹ í˜¸ ìƒì„±

## ğŸ—ï¸ ê¸°ìˆ ì  ì•„í‚¤í…ì²˜

### í”„ë¡ íŠ¸ì—”ë“œ êµ¬ì¡°
```
web/templates/
â”œâ”€â”€ stock.html                    # ë©”ì¸ ì£¼ê°€ ì˜ˆì¸¡ í˜ì´ì§€
â”œâ”€â”€ time_series_prediction.html   # ì‹œê³„ì—´ ì˜ˆì¸¡ í˜ì´ì§€
â””â”€â”€ market_sentiment.html         # ì‹œì¥ ì‹¬ë¦¬ ë¶„ì„ í˜ì´ì§€
```

### ë°±ì—”ë“œ êµ¬ì¡°
```
web/
â”œâ”€â”€ app.py                        # ì£¼ê°€ ì˜ˆì¸¡ ê´€ë ¨ ë¼ìš°íŠ¸
â”œâ”€â”€ blueprints/
â”‚   â””â”€â”€ stock/                   # ì£¼ì‹ ê´€ë ¨ ë¼ìš°íŠ¸
â””â”€â”€ services/
    â”œâ”€â”€ stock_prediction_service.py # ì£¼ê°€ ì˜ˆì¸¡ ì„œë¹„ìŠ¤
    â”œâ”€â”€ technical_analysis_service.py # ê¸°ìˆ ì  ë¶„ì„
    â””â”€â”€ chart_service.py         # ì°¨íŠ¸ ìƒì„± ì„œë¹„ìŠ¤
```

## ğŸ“± UI/UX ì„¤ê³„

### ì˜ˆì¸¡ ëŒ€ì‹œë³´ë“œ
1. **ì£¼ìš” ì§€í‘œ ì˜ì—­**
   - í˜„ì¬ê°€ ë° ë“±ë½ë¥ 
   - ì˜ˆì¸¡ ê°€ê²© ë²”ìœ„
   - ì‹ ë¢°ë„ ì ìˆ˜
   - íˆ¬ì ì‹ í˜¸

2. **ì°¨íŠ¸ ì˜ì—­**
   - ê³¼ê±° ê°€ê²© ë°ì´í„°
   - ì˜ˆì¸¡ì„  í‘œì‹œ
   - ê¸°ìˆ ì  ì§€í‘œ ì˜¤ë²„ë ˆì´
   - ì¸í„°ë™í‹°ë¸Œ ì¤Œ/íŒ¬

3. **ë¶„ì„ ê²°ê³¼ ì˜ì—­**
   - ê¸°ìˆ ì  ì§€í‘œ ìš”ì•½
   - AI ëª¨ë¸ ë¶„ì„ ê²°ê³¼
   - íˆ¬ì ì¶”ì²œì‚¬í•­

### ë°˜ì‘í˜• ì°¨íŠ¸ ë””ìì¸
```css
/* web/static/css/stock-prediction.css */
.prediction-container {
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 20px;
    padding: 20px;
    max-width: 1400px;
    margin: 0 auto;
}

.stock-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
}

.current-price {
    font-size: 2.5rem;
    font-weight: bold;
    margin-bottom: 10px;
}

.price-change {
    font-size: 1.2rem;
    opacity: 0.9;
}

.prediction-chart {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.chart-container {
    height: 400px;
    position: relative;
}

.technical-indicators {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.indicator-card {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    margin: 10px 0;
    border-radius: 8px;
    background: #f8f9fa;
    transition: transform 0.2s ease;
}

.indicator-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.signal-buy {
    border-left: 4px solid #28a745;
}

.signal-sell {
    border-left: 4px solid #dc3545;
}

.signal-hold {
    border-left: 4px solid #ffc107;
}

/* ëª¨ë°”ì¼ ìµœì í™” */
@media (max-width: 768px) {
    .prediction-container {
        grid-template-columns: 1fr;
    }
    
    .current-price {
        font-size: 2rem;
    }
    
    .chart-container {
        height: 300px;
    }
}
```

## ğŸ”§ í•µì‹¬ ê¸°ëŠ¥ êµ¬í˜„

### 1. AI ê¸°ë°˜ ì£¼ê°€ ì˜ˆì¸¡ ëª¨ë¸
```python
# web/services/stock_prediction_service.py
class StockPredictionService:
    def __init__(self):
        self.models = self.load_prediction_models()
        self.technical_indicators = TechnicalAnalysisService()
        self.data_processor = DataProcessor()
    
    def predict_stock_price(self, ticker: str, prediction_days: int = 30) -> Dict[str, Any]:
        """AI ê¸°ë°˜ ì£¼ê°€ ì˜ˆì¸¡"""
        try:
            # 1. ë°ì´í„° ìˆ˜ì§‘ ë° ì „ì²˜ë¦¬
            historical_data = self.get_historical_data(ticker)
            processed_data = self.data_processor.preprocess_data(historical_data)
            
            # 2. ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°
            technical_data = self.technical_indicators.calculate_all_indicators(processed_data)
            
            # 3. ì—¬ëŸ¬ ëª¨ë¸ì„ í†µí•œ ì˜ˆì¸¡
            predictions = {}
            for model_name, model in self.models.items():
                prediction = model.predict(processed_data, technical_data, prediction_days)
                predictions[model_name] = prediction
            
            # 4. ì•™ìƒë¸” ì˜ˆì¸¡ ê²°ê³¼
            ensemble_prediction = self.ensemble_predictions(predictions)
            
            # 5. ì‹ ë¢°ë„ ê³„ì‚°
            confidence_score = self.calculate_confidence_score(predictions)
            
            # 6. íˆ¬ì ì‹ í˜¸ ìƒì„±
            investment_signal = self.generate_investment_signal(
                ensemble_prediction, 
                technical_data, 
                confidence_score
            )
            
            return {
                'ticker': ticker,
                'current_price': historical_data['close'].iloc[-1],
                'predictions': ensemble_prediction,
                'confidence_score': confidence_score,
                'investment_signal': investment_signal,
                'technical_indicators': technical_data,
                'model_predictions': predictions,
                'prediction_date': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"ì£¼ê°€ ì˜ˆì¸¡ ì‹¤íŒ¨ ({ticker}): {e}")
            return {'error': f'ì˜ˆì¸¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {str(e)}'}
    
    def ensemble_predictions(self, predictions: Dict[str, List[float]]) -> Dict[str, Any]:
        """ì—¬ëŸ¬ ëª¨ë¸ì˜ ì˜ˆì¸¡ ê²°ê³¼ë¥¼ ì•™ìƒë¸”"""
        try:
            # ê°€ì¤‘ í‰ê·  ê³„ì‚° (ëª¨ë¸ë³„ ì„±ëŠ¥ì— ë”°ë¥¸ ê°€ì¤‘ì¹˜)
            weights = {
                'lstm': 0.4,
                'transformer': 0.3,
                'prophet': 0.2,
                'arima': 0.1
            }
            
            ensemble_values = []
            for i in range(len(next(iter(predictions.values())))):
                weighted_sum = 0
                total_weight = 0
                
                for model_name, prediction in predictions.items():
                    weight = weights.get(model_name, 0.1)
                    weighted_sum += prediction[i] * weight
                    total_weight += weight
                
                ensemble_values.append(weighted_sum / total_weight)
            
            return {
                'values': ensemble_values,
                'upper_bound': [v * 1.05 for v in ensemble_values],  # 5% ìƒí•œ
                'lower_bound': [v * 0.95 for v in ensemble_values],  # 5% í•˜í•œ
                'trend': self.calculate_trend(ensemble_values)
            }
            
        except Exception as e:
            logger.error(f"ì•™ìƒë¸” ì˜ˆì¸¡ ì‹¤íŒ¨: {e}")
            return {'error': 'ì•™ìƒë¸” ê³„ì‚° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.'}
    
    def calculate_confidence_score(self, predictions: Dict[str, List[float]]) -> float:
        """ì˜ˆì¸¡ ì‹ ë¢°ë„ ê³„ì‚°"""
        try:
            # ëª¨ë¸ ê°„ ì˜ˆì¸¡ ì¼ê´€ì„± ì¸¡ì •
            all_predictions = list(predictions.values())
            
            if not all_predictions:
                return 0.0
            
            # í‘œì¤€í¸ì°¨ ê¸°ë°˜ ì‹ ë¢°ë„ ê³„ì‚°
            variances = []
            for i in range(len(all_predictions[0])):
                values = [pred[i] for pred in all_predictions]
                variance = np.var(values)
                variances.append(variance)
            
            avg_variance = np.mean(variances)
            max_variance = np.max(variances)
            
            # ì‹ ë¢°ë„ ì ìˆ˜ ê³„ì‚° (0-100)
            confidence = max(0, 100 - (avg_variance / max_variance) * 50)
            
            return round(confidence, 2)
            
        except Exception as e:
            logger.error(f"ì‹ ë¢°ë„ ê³„ì‚° ì‹¤íŒ¨: {e}")
            return 50.0  # ê¸°ë³¸ê°’
    
    def generate_investment_signal(self, prediction: Dict[str, Any], 
                                 technical_data: Dict[str, Any], 
                                 confidence: float) -> Dict[str, Any]:
        """íˆ¬ì ì‹ í˜¸ ìƒì„±"""
        try:
            current_price = technical_data.get('current_price', 0)
            predicted_price = prediction['values'][0] if prediction['values'] else current_price
            
            # ê°€ê²© ë³€ë™ë¥  ê³„ì‚°
            price_change_pct = ((predicted_price - current_price) / current_price) * 100
            
            # ê¸°ìˆ ì  ì§€í‘œ ì‹ í˜¸
            rsi_signal = self.analyze_rsi_signal(technical_data.get('rsi', 50))
            macd_signal = self.analyze_macd_signal(technical_data.get('macd', {}))
            bollinger_signal = self.analyze_bollinger_signal(technical_data.get('bollinger', {}))
            
            # ì¢…í•© ì‹ í˜¸ ê²°ì •
            if confidence < 30:
                signal = 'HOLD'
                reason = 'ì˜ˆì¸¡ ì‹ ë¢°ë„ê°€ ë‚®ìŠµë‹ˆë‹¤'
            elif price_change_pct > 5 and rsi_signal == 'BUY':
                signal = 'BUY'
                reason = 'ê°•í•œ ìƒìŠ¹ ì‹ í˜¸'
            elif price_change_pct < -5 and rsi_signal == 'SELL':
                signal = 'SELL'
                reason = 'ê°•í•œ í•˜ë½ ì‹ í˜¸'
            elif abs(price_change_pct) <= 5:
                signal = 'HOLD'
                reason = 'ì•ˆì •ì ì¸ ì¶”ì„¸'
            else:
                signal = 'HOLD'
                reason = 'í˜¼ì¡°ì„¸'
            
            return {
                'signal': signal,
                'reason': reason,
                'price_change_pct': round(price_change_pct, 2),
                'confidence': confidence,
                'technical_signals': {
                    'rsi': rsi_signal,
                    'macd': macd_signal,
                    'bollinger': bollinger_signal
                }
            }
            
        except Exception as e:
            logger.error(f"íˆ¬ì ì‹ í˜¸ ìƒì„± ì‹¤íŒ¨: {e}")
            return {
                'signal': 'HOLD',
                'reason': 'ì‹ í˜¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
                'price_change_pct': 0,
                'confidence': 0
            }
```

### 2. ê¸°ìˆ ì  ë¶„ì„ ì„œë¹„ìŠ¤
```python
# web/services/technical_analysis_service.py
import pandas as pd
import numpy as np
from ta.trend import SMAIndicator, EMAIndicator, MACD
from ta.momentum import RSIIndicator, StochasticOscillator
from ta.volatility import BollingerBands
from ta.volume import VolumeWeightedAveragePrice

class TechnicalAnalysisService:
    def __init__(self):
        self.indicators = {}
    
    def calculate_all_indicators(self, data: pd.DataFrame) -> Dict[str, Any]:
        """ëª¨ë“  ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°"""
        try:
            results = {}
            
            # ì´ë™í‰ê· 
            results['sma'] = self.calculate_sma(data)
            results['ema'] = self.calculate_ema(data)
            
            # ëª¨ë©˜í…€ ì§€í‘œ
            results['rsi'] = self.calculate_rsi(data)
            results['stochastic'] = self.calculate_stochastic(data)
            
            # ì¶”ì„¸ ì§€í‘œ
            results['macd'] = self.calculate_macd(data)
            
            # ë³€ë™ì„± ì§€í‘œ
            results['bollinger'] = self.calculate_bollinger_bands(data)
            results['atr'] = self.calculate_atr(data)
            
            # ê±°ë˜ëŸ‰ ì§€í‘œ
            results['vwap'] = self.calculate_vwap(data)
            results['volume_sma'] = self.calculate_volume_sma(data)
            
            # í˜„ì¬ê°€ ì •ë³´
            results['current_price'] = data['close'].iloc[-1]
            results['price_change'] = self.calculate_price_change(data)
            
            return results
            
        except Exception as e:
            logger.error(f"ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚° ì‹¤íŒ¨: {e}")
            return {}
    
    def calculate_sma(self, data: pd.DataFrame, periods: List[int] = [5, 10, 20, 50]) -> Dict[str, List[float]]:
        """ë‹¨ìˆœì´ë™í‰ê·  ê³„ì‚°"""
        sma_data = {}
        for period in periods:
            sma = SMAIndicator(close=data['close'], window=period)
            sma_data[f'sma_{period}'] = sma.sma_indicator().tolist()
        return sma_data
    
    def calculate_ema(self, data: pd.DataFrame, periods: List[int] = [12, 26]) -> Dict[str, List[float]]:
        """ì§€ìˆ˜ì´ë™í‰ê·  ê³„ì‚°"""
        ema_data = {}
        for period in periods:
            ema = EMAIndicator(close=data['close'], window=period)
            ema_data[f'ema_{period}'] = ema.ema_indicator().tolist()
        return ema_data
    
    def calculate_rsi(self, data: pd.DataFrame, period: int = 14) -> Dict[str, Any]:
        """RSI ê³„ì‚°"""
        rsi_indicator = RSIIndicator(close=data['close'], window=period)
        rsi_values = rsi_indicator.rsi()
        
        current_rsi = rsi_values.iloc[-1]
        
        # RSI ì‹ í˜¸ ë¶„ì„
        if current_rsi > 70:
            signal = 'SELL'
        elif current_rsi < 30:
            signal = 'BUY'
        else:
            signal = 'NEUTRAL'
        
        return {
            'values': rsi_values.tolist(),
            'current': current_rsi,
            'signal': signal
        }
    
    def calculate_macd(self, data: pd.DataFrame) -> Dict[str, Any]:
        """MACD ê³„ì‚°"""
        macd_indicator = MACD(close=data['close'])
        
        macd_line = macd_indicator.macd()
        signal_line = macd_indicator.macd_signal()
        histogram = macd_indicator.macd_diff()
        
        # MACD ì‹ í˜¸ ë¶„ì„
        current_macd = macd_line.iloc[-1]
        current_signal = signal_line.iloc[-1]
        
        if current_macd > current_signal and histogram.iloc[-1] > 0:
            signal = 'BUY'
        elif current_macd < current_signal and histogram.iloc[-1] < 0:
            signal = 'SELL'
        else:
            signal = 'NEUTRAL'
        
        return {
            'macd_line': macd_line.tolist(),
            'signal_line': signal_line.tolist(),
            'histogram': histogram.tolist(),
            'current_macd': current_macd,
            'current_signal': current_signal,
            'signal': signal
        }
    
    def calculate_bollinger_bands(self, data: pd.DataFrame, period: int = 20) -> Dict[str, Any]:
        """ë³¼ë¦°ì € ë°´ë“œ ê³„ì‚°"""
        bb_indicator = BollingerBands(close=data['close'], window=period)
        
        upper_band = bb_indicator.bollinger_hband()
        middle_band = bb_indicator.bollinger_mavg()
        lower_band = bb_indicator.bollinger_lband()
        
        current_price = data['close'].iloc[-1]
        current_upper = upper_band.iloc[-1]
        current_lower = lower_band.iloc[-1]
        
        # ë³¼ë¦°ì € ë°´ë“œ ì‹ í˜¸ ë¶„ì„
        if current_price > current_upper:
            signal = 'SELL'
        elif current_price < current_lower:
            signal = 'BUY'
        else:
            signal = 'NEUTRAL'
        
        return {
            'upper_band': upper_band.tolist(),
            'middle_band': middle_band.tolist(),
            'lower_band': lower_band.tolist(),
            'current_price': current_price,
            'signal': signal
        }
    
    def calculate_price_change(self, data: pd.DataFrame, periods: List[int] = [1, 5, 20]) -> Dict[str, float]:
        """ê°€ê²© ë³€ë™ë¥  ê³„ì‚°"""
        changes = {}
        current_price = data['close'].iloc[-1]
        
        for period in periods:
            if len(data) > period:
                past_price = data['close'].iloc[-period-1]
                change_pct = ((current_price - past_price) / past_price) * 100
                changes[f'{period}d_change'] = round(change_pct, 2)
            else:
                changes[f'{period}d_change'] = 0.0
        
        return changes
```

### 3. ì‹¤ì‹œê°„ ì°¨íŠ¸ ì‹œê°í™”
```javascript
// web/static/js/stock-chart.js
class StockChartManager {
    constructor() {
        this.chart = null;
        this.predictionData = null;
        this.init();
    }
    
    init() {
        this.setupChart();
        this.setupEventListeners();
    }
    
    setupChart() {
        const ctx = document.getElementById('stock-chart').getContext('2d');
        
        this.chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'ì‹¤ì œ ê°€ê²©',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: false
                    },
                    {
                        label: 'ì˜ˆì¸¡ ê°€ê²©',
                        data: [],
                        borderColor: '#f093fb',
                        backgroundColor: 'rgba(240, 147, 251, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += new Intl.NumberFormat('ko-KR').format(context.parsed.y) + 'ì›';
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: 'ë‚ ì§œ'
                        }
                    },
                    y: {
                        display: true,
                        title: {
                            display: true,
                            text: 'ê°€ê²© (ì›)'
                        },
                        ticks: {
                            callback: function(value) {
                                return new Intl.NumberFormat('ko-KR').format(value) + 'ì›';
                            }
                        }
                    }
                }
            }
        });
    }
    
    updateChart(historicalData, predictionData) {
        // ì‹¤ì œ ë°ì´í„°
        const historicalLabels = historicalData.map(d => d.date);
        const historicalPrices = historicalData.map(d => d.close);
        
        // ì˜ˆì¸¡ ë°ì´í„°
        const predictionLabels = predictionData.dates;
        const predictionPrices = predictionData.values;
        
        // ì°¨íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
        this.chart.data.labels = [...historicalLabels, ...predictionLabels];
        this.chart.data.datasets[0].data = [...historicalPrices, ...Array(predictionLabels.length).fill(null)];
        this.chart.data.datasets[1].data = [...Array(historicalLabels.length).fill(null), ...predictionPrices];
        
        this.chart.update();
        
        // ì˜ˆì¸¡ êµ¬ê°„ í•˜ì´ë¼ì´íŠ¸
        this.highlightPredictionArea(historicalLabels.length);
    }
    
    highlightPredictionArea(predictionStartIndex) {
        const chartArea = this.chart.chartArea;
        const ctx = this.chart.ctx;
        
        // ì˜ˆì¸¡ êµ¬ê°„ ë°°ê²½ìƒ‰ ë³€ê²½
        ctx.save();
        ctx.fillStyle = 'rgba(240, 147, 251, 0.1)';
        ctx.fillRect(
            chartArea.left + (predictionStartIndex / this.chart.data.labels.length) * chartArea.width,
            chartArea.top,
            chartArea.width * (1 - predictionStartIndex / this.chart.data.labels.length),
            chartArea.height
        );
        ctx.restore();
    }
    
    addTechnicalIndicators(indicators) {
        // RSI ì°¨íŠ¸ ì¶”ê°€
        if (indicators.rsi) {
            this.addRSIChart(indicators.rsi);
        }
        
        // MACD ì°¨íŠ¸ ì¶”ê°€
        if (indicators.macd) {
            this.addMACDChart(indicators.macd);
        }
        
        // ë³¼ë¦°ì € ë°´ë“œ ì¶”ê°€
        if (indicators.bollinger) {
            this.addBollingerBands(indicators.bollinger);
        }
    }
    
    addRSIChart(rsiData) {
        const rsiCtx = document.getElementById('rsi-chart').getContext('2d');
        
        new Chart(rsiCtx, {
            type: 'line',
            data: {
                labels: rsiData.labels,
                datasets: [{
                    label: 'RSI',
                    data: rsiData.values,
                    borderColor: '#ff6b6b',
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        min: 0,
                        max: 100,
                        grid: {
                            color: function(context) {
                                if (context.tick.value === 30 || context.tick.value === 70) {
                                    return 'rgba(255, 0, 0, 0.3)';
                                }
                                return 'rgba(0, 0, 0, 0.1)';
                            }
                        }
                    }
                },
                plugins: {
                    annotation: {
                        annotations: {
                            overbought: {
                                type: 'line',
                                yMin: 70,
                                yMax: 70,
                                borderColor: 'red',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            },
                            oversold: {
                                type: 'line',
                                yMin: 30,
                                yMax: 30,
                                borderColor: 'green',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            }
                        }
                    }
                }
            }
        });
    }
}
```

## ğŸ“Š ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡°

### ì˜ˆì¸¡ ê´€ë ¨ í…Œì´ë¸”
```sql
CREATE TABLE stock_predictions (
    id SERIAL PRIMARY KEY,
    ticker VARCHAR(10) NOT NULL,
    prediction_date DATE NOT NULL,
    current_price DECIMAL(10,2) NOT NULL,
    predicted_price DECIMAL(10,2) NOT NULL,
    confidence_score DECIMAL(5,2) NOT NULL,
    prediction_model VARCHAR(50) NOT NULL,
    prediction_horizon INTEGER NOT NULL, -- ì˜ˆì¸¡ ê¸°ê°„ (ì¼)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE technical_indicators (
    id SERIAL PRIMARY KEY,
    ticker VARCHAR(10) NOT NULL,
    date DATE NOT NULL,
    rsi DECIMAL(5,2),
    macd DECIMAL(10,4),
    macd_signal DECIMAL(10,4),
    bollinger_upper DECIMAL(10,2),
    bollinger_middle DECIMAL(10,2),
    bollinger_lower DECIMAL(10,2),
    sma_5 DECIMAL(10,2),
    sma_20 DECIMAL(10,2),
    ema_12 DECIMAL(10,2),
    ema_26 DECIMAL(10,2),
    volume_sma DECIMAL(15,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE prediction_models (
    id SERIAL PRIMARY KEY,
    model_name VARCHAR(50) NOT NULL,
    model_type VARCHAR(20) NOT NULL, -- 'lstm', 'transformer', 'prophet', 'arima'
    model_version VARCHAR(20) NOT NULL,
    accuracy_score DECIMAL(5,2),
    is_active BOOLEAN DEFAULT TRUE,
    model_parameters JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE investment_signals (
    id SERIAL PRIMARY KEY,
    ticker VARCHAR(10) NOT NULL,
    signal_type VARCHAR(10) NOT NULL, -- 'BUY', 'SELL', 'HOLD'
    signal_strength DECIMAL(5,2), -- 0-100
    signal_reason TEXT,
    technical_indicators JSONB,
    predicted_price_change DECIMAL(5,2),
    confidence_score DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## ğŸ”„ ì‹¤ì‹œê°„ ë°ì´í„° ì²˜ë¦¬

### ì£¼ê°€ ë°ì´í„° ìˆ˜ì§‘
```python
# web/services/data_collection_service.py
class DataCollectionService:
    def __init__(self):
        self.api_client = StockAPIClient()
        self.cache = redis.Redis(host='localhost', port=6379, db=0)
    
    def get_real_time_price(self, ticker: str) -> Dict[str, Any]:
        """ì‹¤ì‹œê°„ ì£¼ê°€ ì¡°íšŒ"""
        try:
            # ìºì‹œ í™•ì¸
            cache_key = f"price:{ticker}"
            cached_data = self.cache.get(cache_key)
            
            if cached_data:
                return json.loads(cached_data)
            
            # API í˜¸ì¶œ
            price_data = self.api_client.get_current_price(ticker)
            
            # ìºì‹œ ì €ì¥ (1ë¶„)
            self.cache.setex(cache_key, 60, json.dumps(price_data))
            
            return price_data
            
        except Exception as e:
            logger.error(f"ì‹¤ì‹œê°„ ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨ ({ticker}): {e}")
            return {}
    
    def get_historical_data(self, ticker: str, days: int = 365) -> pd.DataFrame:
        """ê³¼ê±° ì£¼ê°€ ë°ì´í„° ì¡°íšŒ"""
        try:
            # ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
            query = f"""
                SELECT date, open, high, low, close, volume
                FROM stock_prices
                WHERE ticker = '{ticker}'
                AND date >= CURRENT_DATE - INTERVAL '{days} days'
                ORDER BY date
            """
            
            df = pd.read_sql(query, self.db_connection)
            
            if df.empty:
                # APIì—ì„œ ë°ì´í„° ìˆ˜ì§‘
                df = self.api_client.get_historical_data(ticker, days)
                
                # ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
                self.save_historical_data(ticker, df)
            
            return df
            
        except Exception as e:
            logger.error(f"ê³¼ê±° ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨ ({ticker}): {e}")
            return pd.DataFrame()
```

## ğŸ” ë³´ì•ˆ ë° ê²€ì¦

### ì˜ˆì¸¡ ëª¨ë¸ ê²€ì¦
```python
# web/services/model_validation_service.py
class ModelValidationService:
    def __init__(self):
        self.validation_metrics = {}
    
    def validate_prediction_model(self, model_name: str, test_data: pd.DataFrame) -> Dict[str, Any]:
        """ì˜ˆì¸¡ ëª¨ë¸ ì„±ëŠ¥ ê²€ì¦"""
        try:
            # ì‹¤ì œ ê°’ê³¼ ì˜ˆì¸¡ ê°’ ë¹„êµ
            actual_values = test_data['close'].values
            predicted_values = self.get_model_predictions(model_name, test_data)
            
            # ì„±ëŠ¥ ì§€í‘œ ê³„ì‚°
            mse = mean_squared_error(actual_values, predicted_values)
            mae = mean_absolute_error(actual_values, predicted_values)
            mape = mean_absolute_percentage_error(actual_values, predicted_values)
            
            # ë°©í–¥ì„± ì •í™•ë„ (ìƒìŠ¹/í•˜ë½ ì˜ˆì¸¡ ì •í™•ë„)
            direction_accuracy = self.calculate_direction_accuracy(actual_values, predicted_values)
            
            return {
                'model_name': model_name,
                'mse': mse,
                'mae': mae,
                'mape': mape,
                'direction_accuracy': direction_accuracy,
                'overall_score': self.calculate_overall_score(mse, mae, mape, direction_accuracy)
            }
            
        except Exception as e:
            logger.error(f"ëª¨ë¸ ê²€ì¦ ì‹¤íŒ¨ ({model_name}): {e}")
            return {'error': str(e)}
    
    def calculate_direction_accuracy(self, actual: np.array, predicted: np.array) -> float:
        """ë°©í–¥ì„± ì •í™•ë„ ê³„ì‚°"""
        actual_direction = np.diff(actual) > 0
        predicted_direction = np.diff(predicted) > 0
        
        correct_predictions = np.sum(actual_direction == predicted_direction)
        total_predictions = len(actual_direction)
        
        return (correct_predictions / total_predictions) * 100 if total_predictions > 0 else 0
```

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™”

### ì˜ˆì¸¡ ê²°ê³¼ ìºì‹±
```python
# web/services/prediction_cache_service.py
class PredictionCacheService:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
    
    def cache_prediction_result(self, ticker: str, prediction_data: Dict[str, Any]):
        """ì˜ˆì¸¡ ê²°ê³¼ ìºì‹±"""
        cache_key = f"prediction:{ticker}"
        self.redis_client.setex(cache_key, 3600, json.dumps(prediction_data))  # 1ì‹œê°„
    
    def get_cached_prediction(self, ticker: str) -> Optional[Dict[str, Any]]:
        """ìºì‹œëœ ì˜ˆì¸¡ ê²°ê³¼ ì¡°íšŒ"""
        cache_key = f"prediction:{ticker}"
        cached_data = self.redis_client.get(cache_key)
        return json.loads(cached_data) if cached_data else None
    
    def invalidate_prediction_cache(self, ticker: str):
        """ì˜ˆì¸¡ ìºì‹œ ë¬´íš¨í™”"""
        cache_key = f"prediction:{ticker}"
        self.redis_client.delete(cache_key)
```

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì „ëµ

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
```python
# tests/test_stock_prediction_service.py
import pytest
from web.services.stock_prediction_service import StockPredictionService

class TestStockPredictionService:
    def test_predict_stock_price(self):
        """ì£¼ê°€ ì˜ˆì¸¡ í…ŒìŠ¤íŠ¸"""
        service = StockPredictionService()
        ticker = "005930"  # ì‚¼ì„±ì „ì
        
        result = service.predict_stock_price(ticker, prediction_days=30)
        
        assert 'predictions' in result
        assert 'confidence_score' in result
        assert 'investment_signal' in result
        assert isinstance(result['confidence_score'], (int, float))
        assert result['confidence_score'] >= 0 and result['confidence_score'] <= 100
    
    def test_ensemble_predictions(self):
        """ì•™ìƒë¸” ì˜ˆì¸¡ í…ŒìŠ¤íŠ¸"""
        service = StockPredictionService()
        
        predictions = {
            'lstm': [100, 101, 102],
            'transformer': [99, 100, 101],
            'prophet': [101, 102, 103],
            'arima': [98, 99, 100]
        }
        
        result = service.ensemble_predictions(predictions)
        
        assert 'values' in result
        assert 'upper_bound' in result
        assert 'lower_bound' in result
        assert len(result['values']) == 3
```

## ğŸš€ ë°°í¬ ë° ìš´ì˜

### í™˜ê²½ ì„¤ì •
```python
# web/config/prediction_config.py
class PredictionConfig:
    # ëª¨ë¸ ì„¤ì •
    MODEL_UPDATE_INTERVAL = 24  # ì‹œê°„
    PREDICTION_HORIZON = 30  # ì¼
    CONFIDENCE_THRESHOLD = 70
    
    # ë°ì´í„° ì„¤ì •
    HISTORICAL_DATA_DAYS = 365
    MIN_DATA_POINTS = 100
    
    # ìºì‹œ ì„¤ì •
    PREDICTION_CACHE_TTL = 3600  # 1ì‹œê°„
    PRICE_CACHE_TTL = 60  # 1ë¶„
    
    # API ì„¤ì •
    STOCK_API_KEY = os.environ.get('STOCK_API_KEY')
    API_RATE_LIMIT = 100  # ë¶„ë‹¹ ìš”ì²­ ìˆ˜
```

## ğŸ“Š ë¶„ì„ ë° ê°œì„ 

### ì˜ˆì¸¡ ì„±ëŠ¥ ë¶„ì„
```python
# web/services/prediction_analytics_service.py
class PredictionAnalyticsService:
    def analyze_prediction_performance(self) -> Dict[str, Any]:
        """ì˜ˆì¸¡ ì„±ëŠ¥ ë¶„ì„"""
        return {
            'model_accuracy': self.get_model_accuracy_stats(),
            'prediction_trends': self.analyze_prediction_trends(),
            'user_satisfaction': self.calculate_user_satisfaction(),
            'signal_effectiveness': self.analyze_signal_effectiveness()
        }
    
    def get_model_accuracy_stats(self) -> Dict[str, float]:
        """ëª¨ë¸ë³„ ì •í™•ë„ í†µê³„"""
        query = """
            SELECT 
                model_name,
                AVG(accuracy_score) as avg_accuracy,
                COUNT(*) as prediction_count
            FROM prediction_performance
            WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
            GROUP BY model_name
        """
        
        results = self.db.execute(query)
        
        accuracy_stats = {}
        for row in results:
            accuracy_stats[row['model_name']] = {
                'avg_accuracy': row['avg_accuracy'],
                'prediction_count': row['prediction_count']
            }
        
        return accuracy_stats
```

## ğŸ”„ í–¥í›„ ê°œì„  ê³„íš

### ë‹¨ê¸° ê°œì„ ì‚¬í•­ (1-2ê°œì›”)
1. **ì‹¤ì‹œê°„ ì˜ˆì¸¡** ì—…ë°ì´íŠ¸
2. **ê°ì • ë¶„ì„** í†µí•©
3. **ë‰´ìŠ¤ ì˜í–¥ë„** ë¶„ì„
4. **ì†Œì…œ ë¯¸ë””ì–´** ë°ì´í„° í™œìš©

### ì¤‘ê¸° ê°œì„ ì‚¬í•­ (3-6ê°œì›”)
1. **ë”¥ëŸ¬ë‹ ëª¨ë¸** ê³ ë„í™”
2. **ë©€í‹° íƒ€ì„í”„ë ˆì„** ë¶„ì„
3. **í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”** ê¸°ëŠ¥
4. **ë¦¬ìŠ¤í¬ ê´€ë¦¬** ì‹œìŠ¤í…œ

### ì¥ê¸° ê°œì„ ì‚¬í•­ (6ê°œì›” ì´ìƒ)
1. **í€€í…€ ì»´í“¨íŒ…** í™œìš©
2. **ê°•í™”í•™ìŠµ** ê¸°ë°˜ ì˜ˆì¸¡
3. **ë¸”ë¡ì²´ì¸** ë°ì´í„° í†µí•©
4. **AI íŠœí„°** ì‹œìŠ¤í…œ

## ğŸ“š ì°¸ê³  ìë£Œ

### ê¸°ìˆ  ìŠ¤íƒ
- **í”„ë¡ íŠ¸ì—”ë“œ**: HTML5, CSS3, JavaScript (ES6+)
- **ì°¨íŠ¸ ë¼ì´ë¸ŒëŸ¬ë¦¬**: Chart.js, D3.js
- **ë°±ì—”ë“œ**: Python Flask
- **AI/ML**: TensorFlow, PyTorch, scikit-learn
- **ë°ì´í„°ë² ì´ìŠ¤**: PostgreSQL, Redis
- **ë°ì´í„° ë¶„ì„**: pandas, numpy, ta-lib

### ë¼ì´ë¸ŒëŸ¬ë¦¬ ë° ë„êµ¬
- **ê¸°ìˆ ì  ë¶„ì„**: TA-Lib, pandas-ta
- **ì‹œê³„ì—´ ë¶„ì„**: Prophet, ARIMA
- **ë”¥ëŸ¬ë‹**: Keras, TensorFlow
- **ì‹œê°í™”**: Plotly, Matplotlib
- **í…ŒìŠ¤íŠ¸**: pytest, Selenium
- **ëª¨ë‹ˆí„°ë§**: Prometheus, Grafana

ì´ ë¬¸ì„œëŠ” Pixie íˆ¬ìì±—ë´‡ì˜ ì£¼ê°€ ì˜ˆì¸¡ ì‹œìŠ¤í…œ ê°œë°œ ê³¼ì •ê³¼ ê¸°ìˆ ì  ì„¸ë¶€ì‚¬í•­ì„ ìƒì„¸íˆ ë‹¤ë£¨ê³  ìˆìŠµë‹ˆë‹¤. ì§€ì†ì ì¸ ëª¨ë¸ ê°œì„ ê³¼ ë°ì´í„° í’ˆì§ˆ í–¥ìƒì„ í†µí•´ ë”ìš± ì •í™•í•œ ì˜ˆì¸¡ì„ ì œê³µí•˜ëŠ” ê²ƒì´ ëª©í‘œì…ë‹ˆë‹¤. 