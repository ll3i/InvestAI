# 📈 Pixie 주가 예측 페이지 개발 문서

## 🎯 페이지 개요

### 목적
AI 기반 기술적 분석과 머신러닝 모델을 활용하여 주가 예측 및 투자 기회 분석을 제공하는 시스템입니다.

### 주요 기능
- AI 기반 주가 예측 모델
- 기술적 지표 분석
- 시계열 예측 알고리즘
- 실시간 차트 시각화
- 투자 신호 생성

## 🏗️ 기술적 아키텍처

### 프론트엔드 구조
```
web/templates/
├── stock.html                    # 메인 주가 예측 페이지
├── time_series_prediction.html   # 시계열 예측 페이지
└── market_sentiment.html         # 시장 심리 분석 페이지
```

### 백엔드 구조
```
web/
├── app.py                        # 주가 예측 관련 라우트
├── blueprints/
│   └── stock/                   # 주식 관련 라우트
└── services/
    ├── stock_prediction_service.py # 주가 예측 서비스
    ├── technical_analysis_service.py # 기술적 분석
    └── chart_service.py         # 차트 생성 서비스
```

## 📱 UI/UX 설계

### 예측 대시보드
1. **주요 지표 영역**
   - 현재가 및 등락률
   - 예측 가격 범위
   - 신뢰도 점수
   - 투자 신호

2. **차트 영역**
   - 과거 가격 데이터
   - 예측선 표시
   - 기술적 지표 오버레이
   - 인터랙티브 줌/팬

3. **분석 결과 영역**
   - 기술적 지표 요약
   - AI 모델 분석 결과
   - 투자 추천사항

### 반응형 차트 디자인
```css
/* web/static/css/stock-prediction.css */
.prediction-container {
    display: grid;
    grid-template-columns: 1fr 300px;
    gap: 20px;
    padding: 20px;
    max-width: 1400px;
    margin: 0 auto;
}

.stock-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
}

.current-price {
    font-size: 2.5rem;
    font-weight: bold;
    margin-bottom: 10px;
}

.price-change {
    font-size: 1.2rem;
    opacity: 0.9;
}

.prediction-chart {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    margin-bottom: 20px;
}

.chart-container {
    height: 400px;
    position: relative;
}

.technical-indicators {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}

.indicator-card {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    margin: 10px 0;
    border-radius: 8px;
    background: #f8f9fa;
    transition: transform 0.2s ease;
}

.indicator-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.signal-buy {
    border-left: 4px solid #28a745;
}

.signal-sell {
    border-left: 4px solid #dc3545;
}

.signal-hold {
    border-left: 4px solid #ffc107;
}

/* 모바일 최적화 */
@media (max-width: 768px) {
    .prediction-container {
        grid-template-columns: 1fr;
    }
    
    .current-price {
        font-size: 2rem;
    }
    
    .chart-container {
        height: 300px;
    }
}
```

## 🔧 핵심 기능 구현

### 1. AI 기반 주가 예측 모델
```python
# web/services/stock_prediction_service.py
class StockPredictionService:
    def __init__(self):
        self.models = self.load_prediction_models()
        self.technical_indicators = TechnicalAnalysisService()
        self.data_processor = DataProcessor()
    
    def predict_stock_price(self, ticker: str, prediction_days: int = 30) -> Dict[str, Any]:
        """AI 기반 주가 예측"""
        try:
            # 1. 데이터 수집 및 전처리
            historical_data = self.get_historical_data(ticker)
            processed_data = self.data_processor.preprocess_data(historical_data)
            
            # 2. 기술적 지표 계산
            technical_data = self.technical_indicators.calculate_all_indicators(processed_data)
            
            # 3. 여러 모델을 통한 예측
            predictions = {}
            for model_name, model in self.models.items():
                prediction = model.predict(processed_data, technical_data, prediction_days)
                predictions[model_name] = prediction
            
            # 4. 앙상블 예측 결과
            ensemble_prediction = self.ensemble_predictions(predictions)
            
            # 5. 신뢰도 계산
            confidence_score = self.calculate_confidence_score(predictions)
            
            # 6. 투자 신호 생성
            investment_signal = self.generate_investment_signal(
                ensemble_prediction, 
                technical_data, 
                confidence_score
            )
            
            return {
                'ticker': ticker,
                'current_price': historical_data['close'].iloc[-1],
                'predictions': ensemble_prediction,
                'confidence_score': confidence_score,
                'investment_signal': investment_signal,
                'technical_indicators': technical_data,
                'model_predictions': predictions,
                'prediction_date': datetime.now().isoformat()
            }
            
        except Exception as e:
            logger.error(f"주가 예측 실패 ({ticker}): {e}")
            return {'error': f'예측 중 오류가 발생했습니다: {str(e)}'}
    
    def ensemble_predictions(self, predictions: Dict[str, List[float]]) -> Dict[str, Any]:
        """여러 모델의 예측 결과를 앙상블"""
        try:
            # 가중 평균 계산 (모델별 성능에 따른 가중치)
            weights = {
                'lstm': 0.4,
                'transformer': 0.3,
                'prophet': 0.2,
                'arima': 0.1
            }
            
            ensemble_values = []
            for i in range(len(next(iter(predictions.values())))):
                weighted_sum = 0
                total_weight = 0
                
                for model_name, prediction in predictions.items():
                    weight = weights.get(model_name, 0.1)
                    weighted_sum += prediction[i] * weight
                    total_weight += weight
                
                ensemble_values.append(weighted_sum / total_weight)
            
            return {
                'values': ensemble_values,
                'upper_bound': [v * 1.05 for v in ensemble_values],  # 5% 상한
                'lower_bound': [v * 0.95 for v in ensemble_values],  # 5% 하한
                'trend': self.calculate_trend(ensemble_values)
            }
            
        except Exception as e:
            logger.error(f"앙상블 예측 실패: {e}")
            return {'error': '앙상블 계산 중 오류가 발생했습니다.'}
    
    def calculate_confidence_score(self, predictions: Dict[str, List[float]]) -> float:
        """예측 신뢰도 계산"""
        try:
            # 모델 간 예측 일관성 측정
            all_predictions = list(predictions.values())
            
            if not all_predictions:
                return 0.0
            
            # 표준편차 기반 신뢰도 계산
            variances = []
            for i in range(len(all_predictions[0])):
                values = [pred[i] for pred in all_predictions]
                variance = np.var(values)
                variances.append(variance)
            
            avg_variance = np.mean(variances)
            max_variance = np.max(variances)
            
            # 신뢰도 점수 계산 (0-100)
            confidence = max(0, 100 - (avg_variance / max_variance) * 50)
            
            return round(confidence, 2)
            
        except Exception as e:
            logger.error(f"신뢰도 계산 실패: {e}")
            return 50.0  # 기본값
    
    def generate_investment_signal(self, prediction: Dict[str, Any], 
                                 technical_data: Dict[str, Any], 
                                 confidence: float) -> Dict[str, Any]:
        """투자 신호 생성"""
        try:
            current_price = technical_data.get('current_price', 0)
            predicted_price = prediction['values'][0] if prediction['values'] else current_price
            
            # 가격 변동률 계산
            price_change_pct = ((predicted_price - current_price) / current_price) * 100
            
            # 기술적 지표 신호
            rsi_signal = self.analyze_rsi_signal(technical_data.get('rsi', 50))
            macd_signal = self.analyze_macd_signal(technical_data.get('macd', {}))
            bollinger_signal = self.analyze_bollinger_signal(technical_data.get('bollinger', {}))
            
            # 종합 신호 결정
            if confidence < 30:
                signal = 'HOLD'
                reason = '예측 신뢰도가 낮습니다'
            elif price_change_pct > 5 and rsi_signal == 'BUY':
                signal = 'BUY'
                reason = '강한 상승 신호'
            elif price_change_pct < -5 and rsi_signal == 'SELL':
                signal = 'SELL'
                reason = '강한 하락 신호'
            elif abs(price_change_pct) <= 5:
                signal = 'HOLD'
                reason = '안정적인 추세'
            else:
                signal = 'HOLD'
                reason = '혼조세'
            
            return {
                'signal': signal,
                'reason': reason,
                'price_change_pct': round(price_change_pct, 2),
                'confidence': confidence,
                'technical_signals': {
                    'rsi': rsi_signal,
                    'macd': macd_signal,
                    'bollinger': bollinger_signal
                }
            }
            
        except Exception as e:
            logger.error(f"투자 신호 생성 실패: {e}")
            return {
                'signal': 'HOLD',
                'reason': '신호 생성 중 오류가 발생했습니다',
                'price_change_pct': 0,
                'confidence': 0
            }
```

### 2. 기술적 분석 서비스
```python
# web/services/technical_analysis_service.py
import pandas as pd
import numpy as np
from ta.trend import SMAIndicator, EMAIndicator, MACD
from ta.momentum import RSIIndicator, StochasticOscillator
from ta.volatility import BollingerBands
from ta.volume import VolumeWeightedAveragePrice

class TechnicalAnalysisService:
    def __init__(self):
        self.indicators = {}
    
    def calculate_all_indicators(self, data: pd.DataFrame) -> Dict[str, Any]:
        """모든 기술적 지표 계산"""
        try:
            results = {}
            
            # 이동평균
            results['sma'] = self.calculate_sma(data)
            results['ema'] = self.calculate_ema(data)
            
            # 모멘텀 지표
            results['rsi'] = self.calculate_rsi(data)
            results['stochastic'] = self.calculate_stochastic(data)
            
            # 추세 지표
            results['macd'] = self.calculate_macd(data)
            
            # 변동성 지표
            results['bollinger'] = self.calculate_bollinger_bands(data)
            results['atr'] = self.calculate_atr(data)
            
            # 거래량 지표
            results['vwap'] = self.calculate_vwap(data)
            results['volume_sma'] = self.calculate_volume_sma(data)
            
            # 현재가 정보
            results['current_price'] = data['close'].iloc[-1]
            results['price_change'] = self.calculate_price_change(data)
            
            return results
            
        except Exception as e:
            logger.error(f"기술적 지표 계산 실패: {e}")
            return {}
    
    def calculate_sma(self, data: pd.DataFrame, periods: List[int] = [5, 10, 20, 50]) -> Dict[str, List[float]]:
        """단순이동평균 계산"""
        sma_data = {}
        for period in periods:
            sma = SMAIndicator(close=data['close'], window=period)
            sma_data[f'sma_{period}'] = sma.sma_indicator().tolist()
        return sma_data
    
    def calculate_ema(self, data: pd.DataFrame, periods: List[int] = [12, 26]) -> Dict[str, List[float]]:
        """지수이동평균 계산"""
        ema_data = {}
        for period in periods:
            ema = EMAIndicator(close=data['close'], window=period)
            ema_data[f'ema_{period}'] = ema.ema_indicator().tolist()
        return ema_data
    
    def calculate_rsi(self, data: pd.DataFrame, period: int = 14) -> Dict[str, Any]:
        """RSI 계산"""
        rsi_indicator = RSIIndicator(close=data['close'], window=period)
        rsi_values = rsi_indicator.rsi()
        
        current_rsi = rsi_values.iloc[-1]
        
        # RSI 신호 분석
        if current_rsi > 70:
            signal = 'SELL'
        elif current_rsi < 30:
            signal = 'BUY'
        else:
            signal = 'NEUTRAL'
        
        return {
            'values': rsi_values.tolist(),
            'current': current_rsi,
            'signal': signal
        }
    
    def calculate_macd(self, data: pd.DataFrame) -> Dict[str, Any]:
        """MACD 계산"""
        macd_indicator = MACD(close=data['close'])
        
        macd_line = macd_indicator.macd()
        signal_line = macd_indicator.macd_signal()
        histogram = macd_indicator.macd_diff()
        
        # MACD 신호 분석
        current_macd = macd_line.iloc[-1]
        current_signal = signal_line.iloc[-1]
        
        if current_macd > current_signal and histogram.iloc[-1] > 0:
            signal = 'BUY'
        elif current_macd < current_signal and histogram.iloc[-1] < 0:
            signal = 'SELL'
        else:
            signal = 'NEUTRAL'
        
        return {
            'macd_line': macd_line.tolist(),
            'signal_line': signal_line.tolist(),
            'histogram': histogram.tolist(),
            'current_macd': current_macd,
            'current_signal': current_signal,
            'signal': signal
        }
    
    def calculate_bollinger_bands(self, data: pd.DataFrame, period: int = 20) -> Dict[str, Any]:
        """볼린저 밴드 계산"""
        bb_indicator = BollingerBands(close=data['close'], window=period)
        
        upper_band = bb_indicator.bollinger_hband()
        middle_band = bb_indicator.bollinger_mavg()
        lower_band = bb_indicator.bollinger_lband()
        
        current_price = data['close'].iloc[-1]
        current_upper = upper_band.iloc[-1]
        current_lower = lower_band.iloc[-1]
        
        # 볼린저 밴드 신호 분석
        if current_price > current_upper:
            signal = 'SELL'
        elif current_price < current_lower:
            signal = 'BUY'
        else:
            signal = 'NEUTRAL'
        
        return {
            'upper_band': upper_band.tolist(),
            'middle_band': middle_band.tolist(),
            'lower_band': lower_band.tolist(),
            'current_price': current_price,
            'signal': signal
        }
    
    def calculate_price_change(self, data: pd.DataFrame, periods: List[int] = [1, 5, 20]) -> Dict[str, float]:
        """가격 변동률 계산"""
        changes = {}
        current_price = data['close'].iloc[-1]
        
        for period in periods:
            if len(data) > period:
                past_price = data['close'].iloc[-period-1]
                change_pct = ((current_price - past_price) / past_price) * 100
                changes[f'{period}d_change'] = round(change_pct, 2)
            else:
                changes[f'{period}d_change'] = 0.0
        
        return changes
```

### 3. 실시간 차트 시각화
```javascript
// web/static/js/stock-chart.js
class StockChartManager {
    constructor() {
        this.chart = null;
        this.predictionData = null;
        this.init();
    }
    
    init() {
        this.setupChart();
        this.setupEventListeners();
    }
    
    setupChart() {
        const ctx = document.getElementById('stock-chart').getContext('2d');
        
        this.chart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '실제 가격',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: false
                    },
                    {
                        label: '예측 가격',
                        data: [],
                        borderColor: '#f093fb',
                        backgroundColor: 'rgba(240, 147, 251, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    intersect: false,
                    mode: 'index'
                },
                plugins: {
                    legend: {
                        position: 'top',
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += new Intl.NumberFormat('ko-KR').format(context.parsed.y) + '원';
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        display: true,
                        title: {
                            display: true,
                            text: '날짜'
                        }
                    },
                    y: {
                        display: true,
                        title: {
                            display: true,
                            text: '가격 (원)'
                        },
                        ticks: {
                            callback: function(value) {
                                return new Intl.NumberFormat('ko-KR').format(value) + '원';
                            }
                        }
                    }
                }
            }
        });
    }
    
    updateChart(historicalData, predictionData) {
        // 실제 데이터
        const historicalLabels = historicalData.map(d => d.date);
        const historicalPrices = historicalData.map(d => d.close);
        
        // 예측 데이터
        const predictionLabels = predictionData.dates;
        const predictionPrices = predictionData.values;
        
        // 차트 데이터 업데이트
        this.chart.data.labels = [...historicalLabels, ...predictionLabels];
        this.chart.data.datasets[0].data = [...historicalPrices, ...Array(predictionLabels.length).fill(null)];
        this.chart.data.datasets[1].data = [...Array(historicalLabels.length).fill(null), ...predictionPrices];
        
        this.chart.update();
        
        // 예측 구간 하이라이트
        this.highlightPredictionArea(historicalLabels.length);
    }
    
    highlightPredictionArea(predictionStartIndex) {
        const chartArea = this.chart.chartArea;
        const ctx = this.chart.ctx;
        
        // 예측 구간 배경색 변경
        ctx.save();
        ctx.fillStyle = 'rgba(240, 147, 251, 0.1)';
        ctx.fillRect(
            chartArea.left + (predictionStartIndex / this.chart.data.labels.length) * chartArea.width,
            chartArea.top,
            chartArea.width * (1 - predictionStartIndex / this.chart.data.labels.length),
            chartArea.height
        );
        ctx.restore();
    }
    
    addTechnicalIndicators(indicators) {
        // RSI 차트 추가
        if (indicators.rsi) {
            this.addRSIChart(indicators.rsi);
        }
        
        // MACD 차트 추가
        if (indicators.macd) {
            this.addMACDChart(indicators.macd);
        }
        
        // 볼린저 밴드 추가
        if (indicators.bollinger) {
            this.addBollingerBands(indicators.bollinger);
        }
    }
    
    addRSIChart(rsiData) {
        const rsiCtx = document.getElementById('rsi-chart').getContext('2d');
        
        new Chart(rsiCtx, {
            type: 'line',
            data: {
                labels: rsiData.labels,
                datasets: [{
                    label: 'RSI',
                    data: rsiData.values,
                    borderColor: '#ff6b6b',
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        min: 0,
                        max: 100,
                        grid: {
                            color: function(context) {
                                if (context.tick.value === 30 || context.tick.value === 70) {
                                    return 'rgba(255, 0, 0, 0.3)';
                                }
                                return 'rgba(0, 0, 0, 0.1)';
                            }
                        }
                    }
                },
                plugins: {
                    annotation: {
                        annotations: {
                            overbought: {
                                type: 'line',
                                yMin: 70,
                                yMax: 70,
                                borderColor: 'red',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            },
                            oversold: {
                                type: 'line',
                                yMin: 30,
                                yMax: 30,
                                borderColor: 'green',
                                borderWidth: 1,
                                borderDash: [5, 5]
                            }
                        }
                    }
                }
            }
        });
    }
}
```

## 📊 데이터베이스 구조

### 예측 관련 테이블
```sql
CREATE TABLE stock_predictions (
    id SERIAL PRIMARY KEY,
    ticker VARCHAR(10) NOT NULL,
    prediction_date DATE NOT NULL,
    current_price DECIMAL(10,2) NOT NULL,
    predicted_price DECIMAL(10,2) NOT NULL,
    confidence_score DECIMAL(5,2) NOT NULL,
    prediction_model VARCHAR(50) NOT NULL,
    prediction_horizon INTEGER NOT NULL, -- 예측 기간 (일)
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE technical_indicators (
    id SERIAL PRIMARY KEY,
    ticker VARCHAR(10) NOT NULL,
    date DATE NOT NULL,
    rsi DECIMAL(5,2),
    macd DECIMAL(10,4),
    macd_signal DECIMAL(10,4),
    bollinger_upper DECIMAL(10,2),
    bollinger_middle DECIMAL(10,2),
    bollinger_lower DECIMAL(10,2),
    sma_5 DECIMAL(10,2),
    sma_20 DECIMAL(10,2),
    ema_12 DECIMAL(10,2),
    ema_26 DECIMAL(10,2),
    volume_sma DECIMAL(15,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE prediction_models (
    id SERIAL PRIMARY KEY,
    model_name VARCHAR(50) NOT NULL,
    model_type VARCHAR(20) NOT NULL, -- 'lstm', 'transformer', 'prophet', 'arima'
    model_version VARCHAR(20) NOT NULL,
    accuracy_score DECIMAL(5,2),
    is_active BOOLEAN DEFAULT TRUE,
    model_parameters JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE investment_signals (
    id SERIAL PRIMARY KEY,
    ticker VARCHAR(10) NOT NULL,
    signal_type VARCHAR(10) NOT NULL, -- 'BUY', 'SELL', 'HOLD'
    signal_strength DECIMAL(5,2), -- 0-100
    signal_reason TEXT,
    technical_indicators JSONB,
    predicted_price_change DECIMAL(5,2),
    confidence_score DECIMAL(5,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 🔄 실시간 데이터 처리

### 주가 데이터 수집
```python
# web/services/data_collection_service.py
class DataCollectionService:
    def __init__(self):
        self.api_client = StockAPIClient()
        self.cache = redis.Redis(host='localhost', port=6379, db=0)
    
    def get_real_time_price(self, ticker: str) -> Dict[str, Any]:
        """실시간 주가 조회"""
        try:
            # 캐시 확인
            cache_key = f"price:{ticker}"
            cached_data = self.cache.get(cache_key)
            
            if cached_data:
                return json.loads(cached_data)
            
            # API 호출
            price_data = self.api_client.get_current_price(ticker)
            
            # 캐시 저장 (1분)
            self.cache.setex(cache_key, 60, json.dumps(price_data))
            
            return price_data
            
        except Exception as e:
            logger.error(f"실시간 가격 조회 실패 ({ticker}): {e}")
            return {}
    
    def get_historical_data(self, ticker: str, days: int = 365) -> pd.DataFrame:
        """과거 주가 데이터 조회"""
        try:
            # 데이터베이스에서 조회
            query = f"""
                SELECT date, open, high, low, close, volume
                FROM stock_prices
                WHERE ticker = '{ticker}'
                AND date >= CURRENT_DATE - INTERVAL '{days} days'
                ORDER BY date
            """
            
            df = pd.read_sql(query, self.db_connection)
            
            if df.empty:
                # API에서 데이터 수집
                df = self.api_client.get_historical_data(ticker, days)
                
                # 데이터베이스에 저장
                self.save_historical_data(ticker, df)
            
            return df
            
        except Exception as e:
            logger.error(f"과거 데이터 조회 실패 ({ticker}): {e}")
            return pd.DataFrame()
```

## 🔐 보안 및 검증

### 예측 모델 검증
```python
# web/services/model_validation_service.py
class ModelValidationService:
    def __init__(self):
        self.validation_metrics = {}
    
    def validate_prediction_model(self, model_name: str, test_data: pd.DataFrame) -> Dict[str, Any]:
        """예측 모델 성능 검증"""
        try:
            # 실제 값과 예측 값 비교
            actual_values = test_data['close'].values
            predicted_values = self.get_model_predictions(model_name, test_data)
            
            # 성능 지표 계산
            mse = mean_squared_error(actual_values, predicted_values)
            mae = mean_absolute_error(actual_values, predicted_values)
            mape = mean_absolute_percentage_error(actual_values, predicted_values)
            
            # 방향성 정확도 (상승/하락 예측 정확도)
            direction_accuracy = self.calculate_direction_accuracy(actual_values, predicted_values)
            
            return {
                'model_name': model_name,
                'mse': mse,
                'mae': mae,
                'mape': mape,
                'direction_accuracy': direction_accuracy,
                'overall_score': self.calculate_overall_score(mse, mae, mape, direction_accuracy)
            }
            
        except Exception as e:
            logger.error(f"모델 검증 실패 ({model_name}): {e}")
            return {'error': str(e)}
    
    def calculate_direction_accuracy(self, actual: np.array, predicted: np.array) -> float:
        """방향성 정확도 계산"""
        actual_direction = np.diff(actual) > 0
        predicted_direction = np.diff(predicted) > 0
        
        correct_predictions = np.sum(actual_direction == predicted_direction)
        total_predictions = len(actual_direction)
        
        return (correct_predictions / total_predictions) * 100 if total_predictions > 0 else 0
```

## 📈 성능 최적화

### 예측 결과 캐싱
```python
# web/services/prediction_cache_service.py
class PredictionCacheService:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
    
    def cache_prediction_result(self, ticker: str, prediction_data: Dict[str, Any]):
        """예측 결과 캐싱"""
        cache_key = f"prediction:{ticker}"
        self.redis_client.setex(cache_key, 3600, json.dumps(prediction_data))  # 1시간
    
    def get_cached_prediction(self, ticker: str) -> Optional[Dict[str, Any]]:
        """캐시된 예측 결과 조회"""
        cache_key = f"prediction:{ticker}"
        cached_data = self.redis_client.get(cache_key)
        return json.loads(cached_data) if cached_data else None
    
    def invalidate_prediction_cache(self, ticker: str):
        """예측 캐시 무효화"""
        cache_key = f"prediction:{ticker}"
        self.redis_client.delete(cache_key)
```

## 🧪 테스트 전략

### 단위 테스트
```python
# tests/test_stock_prediction_service.py
import pytest
from web.services.stock_prediction_service import StockPredictionService

class TestStockPredictionService:
    def test_predict_stock_price(self):
        """주가 예측 테스트"""
        service = StockPredictionService()
        ticker = "005930"  # 삼성전자
        
        result = service.predict_stock_price(ticker, prediction_days=30)
        
        assert 'predictions' in result
        assert 'confidence_score' in result
        assert 'investment_signal' in result
        assert isinstance(result['confidence_score'], (int, float))
        assert result['confidence_score'] >= 0 and result['confidence_score'] <= 100
    
    def test_ensemble_predictions(self):
        """앙상블 예측 테스트"""
        service = StockPredictionService()
        
        predictions = {
            'lstm': [100, 101, 102],
            'transformer': [99, 100, 101],
            'prophet': [101, 102, 103],
            'arima': [98, 99, 100]
        }
        
        result = service.ensemble_predictions(predictions)
        
        assert 'values' in result
        assert 'upper_bound' in result
        assert 'lower_bound' in result
        assert len(result['values']) == 3
```

## 🚀 배포 및 운영

### 환경 설정
```python
# web/config/prediction_config.py
class PredictionConfig:
    # 모델 설정
    MODEL_UPDATE_INTERVAL = 24  # 시간
    PREDICTION_HORIZON = 30  # 일
    CONFIDENCE_THRESHOLD = 70
    
    # 데이터 설정
    HISTORICAL_DATA_DAYS = 365
    MIN_DATA_POINTS = 100
    
    # 캐시 설정
    PREDICTION_CACHE_TTL = 3600  # 1시간
    PRICE_CACHE_TTL = 60  # 1분
    
    # API 설정
    STOCK_API_KEY = os.environ.get('STOCK_API_KEY')
    API_RATE_LIMIT = 100  # 분당 요청 수
```

## 📊 분석 및 개선

### 예측 성능 분석
```python
# web/services/prediction_analytics_service.py
class PredictionAnalyticsService:
    def analyze_prediction_performance(self) -> Dict[str, Any]:
        """예측 성능 분석"""
        return {
            'model_accuracy': self.get_model_accuracy_stats(),
            'prediction_trends': self.analyze_prediction_trends(),
            'user_satisfaction': self.calculate_user_satisfaction(),
            'signal_effectiveness': self.analyze_signal_effectiveness()
        }
    
    def get_model_accuracy_stats(self) -> Dict[str, float]:
        """모델별 정확도 통계"""
        query = """
            SELECT 
                model_name,
                AVG(accuracy_score) as avg_accuracy,
                COUNT(*) as prediction_count
            FROM prediction_performance
            WHERE created_at >= CURRENT_DATE - INTERVAL '30 days'
            GROUP BY model_name
        """
        
        results = self.db.execute(query)
        
        accuracy_stats = {}
        for row in results:
            accuracy_stats[row['model_name']] = {
                'avg_accuracy': row['avg_accuracy'],
                'prediction_count': row['prediction_count']
            }
        
        return accuracy_stats
```

## 🔄 향후 개선 계획

### 단기 개선사항 (1-2개월)
1. **실시간 예측** 업데이트
2. **감정 분석** 통합
3. **뉴스 영향도** 분석
4. **소셜 미디어** 데이터 활용

### 중기 개선사항 (3-6개월)
1. **딥러닝 모델** 고도화
2. **멀티 타임프레임** 분석
3. **포트폴리오 최적화** 기능
4. **리스크 관리** 시스템

### 장기 개선사항 (6개월 이상)
1. **퀀텀 컴퓨팅** 활용
2. **강화학습** 기반 예측
3. **블록체인** 데이터 통합
4. **AI 튜터** 시스템

## 📚 참고 자료

### 기술 스택
- **프론트엔드**: HTML5, CSS3, JavaScript (ES6+)
- **차트 라이브러리**: Chart.js, D3.js
- **백엔드**: Python Flask
- **AI/ML**: TensorFlow, PyTorch, scikit-learn
- **데이터베이스**: PostgreSQL, Redis
- **데이터 분석**: pandas, numpy, ta-lib

### 라이브러리 및 도구
- **기술적 분석**: TA-Lib, pandas-ta
- **시계열 분석**: Prophet, ARIMA
- **딥러닝**: Keras, TensorFlow
- **시각화**: Plotly, Matplotlib
- **테스트**: pytest, Selenium
- **모니터링**: Prometheus, Grafana

이 문서는 Pixie 투자챗봇의 주가 예측 시스템 개발 과정과 기술적 세부사항을 상세히 다루고 있습니다. 지속적인 모델 개선과 데이터 품질 향상을 통해 더욱 정확한 예측을 제공하는 것이 목표입니다. 