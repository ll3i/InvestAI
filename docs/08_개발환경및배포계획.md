# 08. 개발 환경 및 배포 계획

## 8.1 개발 환경 구성

### 8.1.1 개발 스택 및 도구

**프론트엔드 개발 환경**

1. **핵심 기술 스택**
   ```json
   {
     "framework": "React 18.2.0",
     "language": "TypeScript 5.0",
     "styling": "Tailwind CSS 3.3",
     "state_management": "Redux Toolkit 1.9",
     "routing": "React Router 6.8",
     "charts": "Chart.js 4.2, D3.js 7.8",
     "ui_components": "Material-UI 5.11",
     "build_tool": "Vite 4.3",
     "testing": "Jest 29.5, React Testing Library 14.0"
   }
   ```

2. **개발 도구**
   - IDE: Visual Studio Code
   - 버전 관리: Git, GitHub
   - 패키지 관리: npm / yarn
   - 코드 품질: ESLint, Prettier
   - 디버깅: React DevTools, Redux DevTools

**백엔드 개발 환경**

1. **핵심 기술 스택**
   ```python
   # requirements.txt
   Flask==2.3.2
   Flask-CORS==4.0.0
   Flask-SQLAlchemy==3.0.5
   Flask-JWT-Extended==4.5.2
   
   # AI/ML Libraries
   openai==1.3.0
   anthropic==0.7.0
   transformers==4.35.0
   torch==2.1.0
   tensorflow==2.14.0
   
   # Data Processing
   pandas==2.0.3
   numpy==1.24.3
   scikit-learn==1.3.0
   yfinance==0.2.28
   
   # Database
   psycopg2-binary==2.9.7
   redis==5.0.0
   pymongo==4.5.0
   sqlalchemy==2.0.20
   
   # Async & Queue
   celery==5.3.1
   kafka-python==2.0.2
   asyncio==3.4.3
   ```

2. **개발 도구**
   - IDE: PyCharm Professional / VS Code
   - API 테스팅: Postman, Swagger
   - 프로파일링: cProfile, line_profiler
   - 로깅: Python logging, Sentry
   - 모니터링: Prometheus, Grafana

**데이터베이스 환경**

1. **주요 데이터베이스**
   ```yaml
   databases:
     relational:
       primary: PostgreSQL 15.3
       backup: MySQL 8.0
     
     nosql:
       document: MongoDB 6.0
       cache: Redis 7.0
       timeseries: InfluxDB 2.7
     
     cloud:
       primary: Supabase (PostgreSQL)
       backup: AWS RDS
       warehouse: BigQuery
   ```

2. **데이터베이스 도구**
   - 관리: pgAdmin, MongoDB Compass
   - 마이그레이션: Alembic, Flyway
   - 백업: pg_dump, mongodump
   - 모니터링: pg_stat_statements, MongoDB Atlas

### 8.1.2 개발 인프라

**로컬 개발 환경**

1. **컨테이너화**
   ```dockerfile
   # Dockerfile
   FROM python:3.11-slim
   
   WORKDIR /app
   
   # 시스템 의존성 설치
   RUN apt-get update && apt-get install -y \
       gcc \
       g++ \
       git \
       curl \
       && rm -rf /var/lib/apt/lists/*
   
   # Python 의존성 설치
   COPY requirements.txt .
   RUN pip install --no-cache-dir -r requirements.txt
   
   # 애플리케이션 코드 복사
   COPY . .
   
   # 환경 변수 설정
   ENV FLASK_APP=app.py
   ENV FLASK_ENV=development
   
   EXPOSE 5000
   
   CMD ["flask", "run", "--host=0.0.0.0"]
   ```

2. **Docker Compose 구성**
   ```yaml
   # docker-compose.yml
   version: '3.8'
   
   services:
     web:
       build: .
       ports:
         - "5000:5000"
       environment:
         - DATABASE_URL=postgresql://user:pass@db:5432/pixie
         - REDIS_URL=redis://redis:6379
       depends_on:
         - db
         - redis
       volumes:
         - .:/app
     
     db:
       image: postgres:15
       environment:
         - POSTGRES_DB=pixie
         - POSTGRES_USER=user
         - POSTGRES_PASSWORD=pass
       volumes:
         - postgres_data:/var/lib/postgresql/data
     
     redis:
       image: redis:7-alpine
       ports:
         - "6379:6379"
     
     nginx:
       image: nginx:alpine
       ports:
         - "80:80"
       volumes:
         - ./nginx.conf:/etc/nginx/nginx.conf
       depends_on:
         - web
   
   volumes:
     postgres_data:
   ```

**클라우드 개발 환경**

1. **AWS 개발 환경**
   - EC2: 개발 서버 (t3.large)
   - RDS: 개발 데이터베이스
   - S3: 정적 파일 저장
   - CloudWatch: 로그 및 모니터링
   - Lambda: 서버리스 함수

2. **개발 환경 자동화**
   ```bash
   # setup_dev_env.sh
   #!/bin/bash
   
   # Python 가상환경 생성
   python -m venv venv
   source venv/bin/activate
   
   # 의존성 설치
   pip install -r requirements.txt
   pip install -r requirements-dev.txt
   
   # 데이터베이스 초기화
   flask db init
   flask db migrate
   flask db upgrade
   
   # 초기 데이터 로드
   python scripts/load_initial_data.py
   
   # 환경변수 설정
   cp .env.example .env
   echo "Please update .env with your API keys"
   
   # Pre-commit hooks 설치
   pre-commit install
   
   echo "Development environment setup complete!"
   ```

## 8.2 개발 프로세스

### 8.2.1 개발 방법론

**애자일 스크럼 프로세스**

1. **스프린트 구성**
   - 스프린트 기간: 2주
   - 스프린트 계획: 매 스프린트 첫날
   - 일일 스탠드업: 매일 오전 10시
   - 스프린트 리뷰: 스프린트 마지막 날
   - 회고: 스프린트 종료 후

2. **팀 구성 및 역할**
   ```
   Product Owner (1명)
   ├── Scrum Master (1명)
   ├── Development Team
   │   ├── Backend Engineers (3명)
   │   ├── Frontend Engineers (2명)
   │   ├── AI/ML Engineers (3명)
   │   ├── Data Engineers (2명)
   │   └── DevOps Engineer (1명)
   ├── QA Team (2명)
   └── UX/UI Designer (1명)
   ```

3. **개발 프로세스 플로우**
   ```mermaid
   graph LR
   A[요구사항 분석] --> B[설계]
   B --> C[구현]
   C --> D[코드 리뷰]
   D --> E[테스팅]
   E --> F[배포]
   F --> G[모니터링]
   G --> A
   ```

### 8.2.2 버전 관리 및 브랜치 전략

**Git Flow 전략**

1. **브랜치 구조**
   ```
   main (production)
   ├── develop (개발 통합)
   ├── feature/* (기능 개발)
   ├── release/* (릴리즈 준비)
   ├── hotfix/* (긴급 수정)
   └── bugfix/* (버그 수정)
   ```

2. **브랜치 운영 규칙**
   ```bash
   # 기능 개발
   git checkout -b feature/PIXIE-123-add-portfolio-optimizer
   
   # 커밋 메시지 컨벤션
   # type(scope): subject
   # 
   # Types: feat, fix, docs, style, refactor, test, chore
   
   git commit -m "feat(portfolio): Add Sharpe ratio optimization"
   
   # Pull Request 체크리스트
   - [ ] 코드 리뷰 완료
   - [ ] 단위 테스트 통과
   - [ ] 통합 테스트 통과
   - [ ] 문서 업데이트
   - [ ] 성능 테스트 완료
   ```

### 8.2.3 CI/CD 파이프라인

**GitHub Actions 워크플로우**

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install -r requirements.txt
        pip install pytest pytest-cov
    
    - name: Run tests
      run: |
        pytest tests/ --cov=src --cov-report=xml
    
    - name: Upload coverage
      uses: codecov/codecov-action@v3
    
  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Build Docker image
      run: |
        docker build -t pixie:${{ github.sha }} .
    
    - name: Push to ECR
      env:
        AWS_REGION: ap-northeast-2
      run: |
        aws ecr get-login-password | docker login --username AWS --password-stdin $ECR_REGISTRY
        docker tag pixie:${{ github.sha }} $ECR_REGISTRY/pixie:${{ github.sha }}
        docker push $ECR_REGISTRY/pixie:${{ github.sha }}
  
  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Deploy to ECS
      run: |
        aws ecs update-service \
          --cluster pixie-cluster \
          --service pixie-service \
          --force-new-deployment
```

## 8.3 테스팅 전략

### 8.3.1 테스트 레벨 및 커버리지

**테스트 피라미드**

1. **단위 테스트 (70%)**
   ```python
   # tests/unit/test_portfolio_optimizer.py
   import pytest
   from src.portfolio import PortfolioOptimizer
   
   class TestPortfolioOptimizer:
       def setup_method(self):
           self.optimizer = PortfolioOptimizer()
       
       def test_sharpe_ratio_calculation(self):
           returns = [0.1, 0.05, -0.02, 0.08]
           risk_free_rate = 0.03
           
           sharpe = self.optimizer.calculate_sharpe_ratio(
               returns, risk_free_rate
           )
           
           assert sharpe > 0
           assert isinstance(sharpe, float)
       
       @pytest.mark.parametrize("weights,expected", [
           ([0.5, 0.5], 1.0),
           ([0.3, 0.3, 0.4], 1.0),
           ([1.0], 1.0)
       ])
       def test_weights_sum_to_one(self, weights, expected):
           assert sum(weights) == pytest.approx(expected)
   ```

2. **통합 테스트 (20%)**
   ```python
   # tests/integration/test_ai_chain.py
   import pytest
   from src.investment_advisor import InvestmentAdvisor
   
   @pytest.mark.integration
   class TestAIChain:
       def test_full_ai_chain_execution(self):
           advisor = InvestmentAdvisor()
           
           # AI-A → AI-A2 → AI-B → Final
           response = advisor.chat(
               "삼성전자 투자해도 될까요?",
               session_id="test-session"
           )
           
           assert response is not None
           assert 'recommendation' in response
           assert 'risk_assessment' in response
           assert len(response['ai_responses']) == 4
   ```

3. **E2E 테스트 (10%)**
   ```python
   # tests/e2e/test_user_journey.py
   from selenium import webdriver
   from selenium.webdriver.common.by import By
   
   class TestUserJourney:
       def setup_method(self):
           self.driver = webdriver.Chrome()
           self.driver.get("http://localhost:5000")
       
       def test_complete_investment_flow(self):
           # 로그인
           self.driver.find_element(By.ID, "email").send_keys("test@example.com")
           self.driver.find_element(By.ID, "password").send_keys("password")
           self.driver.find_element(By.ID, "login-btn").click()
           
           # 투자 성향 분석
           self.driver.find_element(By.LINK_TEXT, "투자 성향 분석").click()
           # ... 10개 질문 답변
           
           # AI 상담
           self.driver.find_element(By.ID, "chat-input").send_keys("포트폴리오 추천해줘")
           self.driver.find_element(By.ID, "send-btn").click()
           
           # 결과 확인
           response = self.driver.find_element(By.CLASS_NAME, "ai-response")
           assert "추천 포트폴리오" in response.text
   ```

### 8.3.2 성능 테스트

**부하 테스트 시나리오**

```python
# tests/performance/locustfile.py
from locust import HttpUser, task, between

class PixieUser(HttpUser):
    wait_time = between(1, 3)
    
    def on_start(self):
        # 로그인
        self.client.post("/api/auth/login", json={
            "email": "test@example.com",
            "password": "password"
        })
    
    @task(3)
    def view_dashboard(self):
        self.client.get("/api/dashboard")
    
    @task(5)
    def ai_chat(self):
        self.client.post("/api/chat", json={
            "message": "오늘 시장 어때?",
            "session_id": "test-session"
        })
    
    @task(2)
    def get_portfolio(self):
        self.client.get("/api/portfolio")
    
    @task(1)
    def get_news(self):
        self.client.get("/api/news/latest")
```

**성능 목표**
- 응답 시간: P95 < 500ms
- 처리량: 1,000 TPS
- 동시 사용자: 10,000명
- 가용성: 99.9%

## 8.4 배포 계획

### 8.4.1 배포 아키텍처

**AWS 기반 프로덕션 아키텍처**

```yaml
Production Infrastructure:
  Region: ap-northeast-2 (Seoul)
  
  Compute:
    ECS Fargate:
      - API Servers: 10 tasks (auto-scaling 5-20)
      - Worker Nodes: 5 tasks (auto-scaling 3-10)
    
    Lambda Functions:
      - Data Collection: Scheduled (cron)
      - Webhook Handlers: Event-driven
  
  Storage:
    RDS Aurora PostgreSQL:
      - Multi-AZ deployment
      - Read replicas: 2
      - Automated backups: 7 days
    
    ElastiCache Redis:
      - Cluster mode enabled
      - 3 shards, 2 replicas each
    
    S3:
      - Static assets
      - Data lake
      - Backup storage
  
  Network:
    CloudFront CDN:
      - Global edge locations
      - SSL/TLS termination
    
    Application Load Balancer:
      - Health checks
      - SSL certificates
      - Path-based routing
    
    VPC:
      - Public subnets: 2 (ALB)
      - Private subnets: 4 (Application)
      - Database subnets: 2 (RDS)
  
  Security:
    WAF:
      - DDoS protection
      - Rate limiting
      - IP filtering
    
    Secrets Manager:
      - API keys
      - Database credentials
      - SSL certificates
```

### 8.4.2 배포 단계 및 일정

**Phase 1: MVP 배포 (2024년 Q1)**

1. **Week 1-2: 인프라 구축**
   - AWS 계정 설정
   - VPC 및 네트워크 구성
   - 기본 보안 설정

2. **Week 3-4: 핵심 서비스 배포**
   - 데이터베이스 마이그레이션
   - API 서버 배포
   - 프론트엔드 배포

3. **Week 5-6: 모니터링 구축**
   - CloudWatch 대시보드
   - 알림 설정
   - 로그 수집 시스템

**Phase 2: 베타 서비스 (2024년 Q2)**

1. **확장성 개선**
   - Auto-scaling 정책 수립
   - 캐싱 전략 구현
   - CDN 최적화

2. **보안 강화**
   - 침투 테스트
   - 보안 감사
   - HTTPS 전환

**Phase 3: 정식 출시 (2024년 Q3)**

1. **성능 최적화**
   - 데이터베이스 튜닝
   - 코드 최적화
   - 리소스 효율화

2. **글로벌 확장 준비**
   - Multi-region 설정
   - 다국어 지원
   - 규제 준수

### 8.4.3 롤백 및 복구 계획

**Blue-Green 배포 전략**

```bash
#!/bin/bash
# deploy.sh

# 현재 활성 환경 확인
CURRENT_ENV=$(aws elbv2 describe-target-groups --names pixie-tg --query 'TargetGroups[0].Tags[?Key==`Environment`].Value' --output text)

if [ "$CURRENT_ENV" == "blue" ]; then
    NEW_ENV="green"
else
    NEW_ENV="blue"
fi

echo "Deploying to $NEW_ENV environment..."

# 새 환경에 배포
aws ecs update-service \
    --cluster pixie-cluster \
    --service pixie-$NEW_ENV \
    --force-new-deployment

# 헬스체크 대기
sleep 60

# 헬스체크 확인
HEALTH_STATUS=$(aws elbv2 describe-target-health --target-group-arn $NEW_ENV_TG_ARN --query 'TargetHealthDescriptions[0].TargetHealth.State' --output text)

if [ "$HEALTH_STATUS" == "healthy" ]; then
    echo "Health check passed. Switching traffic..."
    
    # 트래픽 전환
    aws elbv2 modify-listener \
        --listener-arn $LISTENER_ARN \
        --default-actions Type=forward,TargetGroupArn=$NEW_ENV_TG_ARN
    
    echo "Deployment successful!"
else
    echo "Health check failed. Rolling back..."
    exit 1
fi
```

**재해 복구 계획**

1. **백업 전략**
   - 일일 전체 백업
   - 시간별 증분 백업
   - 지역 간 복제

2. **복구 절차**
   - RTO: 1시간
   - RPO: 15분
   - 자동 페일오버

이러한 체계적인 개발 환경과 배포 계획을 통해 Pixie 서비스는 안정적이고 확장 가능한 방식으로 사용자에게 제공될 것입니다.