# 📰 Pixie 뉴스/이슈 페이지 개발 문서

## 🎯 페이지 개요

### 목적
실시간 금융 뉴스를 수집, 분석하고 투자자에게 관련성 높은 정보를 제공하는 종합 뉴스 플랫폼입니다.

### 주요 기능
- 실시간 뉴스 수집 및 분석
- AI 기반 감정 분석
- 개인화된 뉴스 필터링
- 투자 영향도 평가
- 뉴스 기반 투자 신호 생성

## 🏗️ 기술적 아키텍처

### 프론트엔드 구조
```
web/templates/
├── news.html                    # 메인 뉴스 페이지
├── news_enhanced.html           # 향상된 뉴스 페이지
└── news_detail.html             # 뉴스 상세 페이지
```

### 백엔드 구조
```
web/
├── app.py                       # 뉴스 관련 라우트
├── blueprints/
│   └── news/                   # 뉴스 관련 라우트
└── services/
    ├── news_collection_service.py # 뉴스 수집 서비스
    ├── sentiment_analysis_service.py # 감정 분석 서비스
    └── news_impact_service.py   # 뉴스 영향도 분석
```

## 📱 UI/UX 설계

### 뉴스 대시보드
1. **헤드라인 영역**
   - 주요 뉴스 하이라이트
   - 긴급 알림 배너
   - 실시간 업데이트 표시

2. **카테고리 필터**
   - 섹터별 분류
   - 중요도별 정렬
   - 시간대별 필터

3. **뉴스 카드 레이아웃**
   - 제목 및 요약
   - 감정 분석 결과
   - 영향도 점수
   - 관련 종목 태그

### 반응형 뉴스 디자인
```css
/* web/static/css/news.css */
.news-container {
    display: grid;
    grid-template-columns: 1fr 350px;
    gap: 20px;
    padding: 20px;
    max-width: 1400px;
    margin: 0 auto;
}

.news-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    margin-bottom: 20px;
}

.breaking-news {
    background: #dc3545;
    color: white;
    padding: 10px 20px;
    border-radius: 8px;
    margin-bottom: 15px;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.news-card {
    background: white;
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 15px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    transition: transform 0.3s ease;
    border-left: 4px solid #667eea;
}

.news-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
}

.news-title {
    font-size: 1.2rem;
    font-weight: bold;
    margin-bottom: 10px;
    color: #333;
}

.news-summary {
    color: #666;
    line-height: 1.5;
    margin-bottom: 15px;
}

.news-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.9rem;
    color: #888;
}

.sentiment-indicator {
    display: flex;
    align-items: center;
    gap: 5px;
}

.sentiment-positive {
    color: #28a745;
}

.sentiment-negative {
    color: #dc3545;
}

.sentiment-neutral {
    color: #ffc107;
}

.impact-score {
    background: #f8f9fa;
    padding: 5px 10px;
    border-radius: 15px;
    font-weight: bold;
}

.related-stocks {
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    margin-top: 10px;
}

.stock-tag {
    background: #e9ecef;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.8rem;
    color: #495057;
}

.news-sidebar {
    background: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    height: fit-content;
}

.category-filter {
    margin-bottom: 20px;
}

.filter-button {
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    padding: 8px 15px;
    border-radius: 20px;
    margin: 2px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.filter-button.active {
    background: #667eea;
    color: white;
    border-color: #667eea;
}

/* 모바일 최적화 */
@media (max-width: 768px) {
    .news-container {
        grid-template-columns: 1fr;
    }
    
    .news-card {
        padding: 15px;
    }
    
    .news-title {
        font-size: 1.1rem;
    }
}
```

## 🔧 핵심 기능 구현

### 1. 뉴스 수집 및 처리 서비스
```python
# web/services/news_collection_service.py
class NewsCollectionService:
    def __init__(self):
        self.api_clients = {
            'naver': NaverNewsAPI(),
            'yahoo': YahooFinanceAPI(),
            'reuters': ReutersAPI()
        }
        self.processor = NewsDataProcessor()
        self.cache = redis.Redis(host='localhost', port=6379, db=0)
    
    def collect_real_time_news(self) -> List[Dict[str, Any]]:
        """실시간 뉴스 수집"""
        try:
            all_news = []
            
            for source, client in self.api_clients.items():
                try:
                    news_data = client.get_latest_news()
                    processed_news = self.processor.process_news(news_data, source)
                    all_news.extend(processed_news)
                except Exception as e:
                    logger.error(f"뉴스 수집 실패 ({source}): {e}")
                    continue
            
            # 중복 제거 및 정렬
            unique_news = self.remove_duplicates(all_news)
            sorted_news = self.sort_by_relevance(unique_news)
            
            # 캐시 저장
            self.cache_news_data(sorted_news)
            
            return sorted_news
            
        except Exception as e:
            logger.error(f"실시간 뉴스 수집 실패: {e}")
            return []
    
    def process_news(self, raw_news: List[Dict[str, Any]], source: str) -> List[Dict[str, Any]]:
        """뉴스 데이터 전처리"""
        processed_news = []
        
        for news in raw_news:
            try:
                # 기본 정보 추출
                processed_item = {
                    'title': self.clean_text(news.get('title', '')),
                    'content': self.clean_text(news.get('content', '')),
                    'url': news.get('url', ''),
                    'source': source,
                    'published_at': self.parse_datetime(news.get('published_at')),
                    'category': self.categorize_news(news.get('title', '')),
                    'keywords': self.extract_keywords(news.get('title', '') + ' ' + news.get('content', '')),
                    'related_stocks': self.extract_stock_symbols(news.get('title', '') + ' ' + news.get('content', ''))
                }
                
                # 유효성 검사
                if self.validate_news_item(processed_item):
                    processed_news.append(processed_item)
                    
            except Exception as e:
                logger.error(f"뉴스 처리 실패: {e}")
                continue
        
        return processed_news
    
    def categorize_news(self, title: str) -> str:
        """뉴스 카테고리 분류"""
        categories = {
            'earnings': ['실적', '수익', '매출', '영업이익', '당기순이익'],
            'merger': ['인수', '합병', 'M&A', '매각', '투자'],
            'regulation': ['규제', '법안', '정책', '감독', '제재'],
            'market': ['시장', '거래', '주가', '지수', '동향'],
            'technology': ['기술', '혁신', '개발', '특허', 'AI'],
            'economy': ['경제', '금리', '인플레이션', 'GDP', '고용']
        }
        
        title_lower = title.lower()
        
        for category, keywords in categories.items():
            if any(keyword in title_lower for keyword in keywords):
                return category
        
        return 'general'
    
    def extract_stock_symbols(self, text: str) -> List[str]:
        """뉴스에서 관련 종목 추출"""
        # 한국 주식 종목 코드 패턴 (6자리 숫자)
        stock_pattern = r'\b\d{6}\b'
        stock_codes = re.findall(stock_pattern, text)
        
        # 종목명 매칭
        stock_names = self.get_stock_name_matches(text)
        
        return list(set(stock_codes + stock_names))
    
    def extract_keywords(self, text: str) -> List[str]:
        """키워드 추출"""
        # 형태소 분석을 통한 키워드 추출
        from konlpy.tag import Okt
        
        okt = Okt()
        nouns = okt.nouns(text)
        
        # 빈도수 기반 키워드 선택
        from collections import Counter
        word_count = Counter(nouns)
        
        # 상위 10개 키워드 반환
        return [word for word, count in word_count.most_common(10) if len(word) > 1]
```

### 2. 감정 분석 서비스
```python
# web/services/sentiment_analysis_service.py
class SentimentAnalysisService:
    def __init__(self):
        self.model = self.load_sentiment_model()
        self.keywords = self.load_sentiment_keywords()
    
    def analyze_news_sentiment(self, news_data: Dict[str, Any]) -> Dict[str, Any]:
        """뉴스 감정 분석"""
        try:
            # 텍스트 전처리
            text = f"{news_data['title']} {news_data['content']}"
            processed_text = self.preprocess_text(text)
            
            # 감정 분석 수행
            sentiment_score = self.model.predict_sentiment(processed_text)
            
            # 키워드 기반 감정 분석
            keyword_sentiment = self.analyze_keyword_sentiment(processed_text)
            
            # 종합 감정 점수 계산
            overall_sentiment = self.calculate_overall_sentiment(sentiment_score, keyword_sentiment)
            
            # 감정 레이블 결정
            sentiment_label = self.determine_sentiment_label(overall_sentiment)
            
            return {
                'sentiment_score': overall_sentiment,
                'sentiment_label': sentiment_label,
                'confidence': self.calculate_confidence(sentiment_score, keyword_sentiment),
                'positive_keywords': keyword_sentiment['positive'],
                'negative_keywords': keyword_sentiment['negative'],
                'neutral_keywords': keyword_sentiment['neutral']
            }
            
        except Exception as e:
            logger.error(f"감정 분석 실패: {e}")
            return {
                'sentiment_score': 0,
                'sentiment_label': 'neutral',
                'confidence': 0
            }
    
    def analyze_keyword_sentiment(self, text: str) -> Dict[str, Any]:
        """키워드 기반 감정 분석"""
        positive_keywords = []
        negative_keywords = []
        neutral_keywords = []
        
        words = text.split()
        
        for word in words:
            if word in self.keywords['positive']:
                positive_keywords.append(word)
            elif word in self.keywords['negative']:
                negative_keywords.append(word)
            else:
                neutral_keywords.append(word)
        
        return {
            'positive': positive_keywords,
            'negative': negative_keywords,
            'neutral': neutral_keywords,
            'positive_count': len(positive_keywords),
            'negative_count': len(negative_keywords)
        }
    
    def calculate_overall_sentiment(self, model_score: float, keyword_sentiment: Dict[str, Any]) -> float:
        """종합 감정 점수 계산"""
        # 모델 점수 (0-1)
        model_weight = 0.7
        
        # 키워드 기반 점수
        positive_count = keyword_sentiment['positive_count']
        negative_count = keyword_sentiment['negative_count']
        total_keywords = positive_count + negative_count
        
        if total_keywords == 0:
            keyword_score = 0.5  # 중립
        else:
            keyword_score = positive_count / total_keywords
        
        keyword_weight = 0.3
        
        # 가중 평균 계산
        overall_score = (model_score * model_weight) + (keyword_score * keyword_weight)
        
        return round(overall_score, 3)
    
    def determine_sentiment_label(self, score: float) -> str:
        """감정 레이블 결정"""
        if score >= 0.6:
            return 'positive'
        elif score <= 0.4:
            return 'negative'
        else:
            return 'neutral'
```

### 3. 뉴스 영향도 분석 서비스
```python
# web/services/news_impact_service.py
class NewsImpactService:
    def __init__(self):
        self.stock_data_service = StockDataService()
        self.sentiment_service = SentimentAnalysisService()
    
    def analyze_news_impact(self, news_data: Dict[str, Any]) -> Dict[str, Any]:
        """뉴스 영향도 분석"""
        try:
            # 감정 분석
            sentiment_result = self.sentiment_service.analyze_news_sentiment(news_data)
            
            # 관련 종목 분석
            related_stocks = news_data.get('related_stocks', [])
            stock_impacts = {}
            
            for stock in related_stocks:
                stock_impact = self.analyze_stock_impact(stock, news_data, sentiment_result)
                stock_impacts[stock] = stock_impact
            
            # 전체 영향도 계산
            overall_impact = self.calculate_overall_impact(stock_impacts, sentiment_result)
            
            # 투자 신호 생성
            investment_signal = self.generate_investment_signal(overall_impact, sentiment_result)
            
            return {
                'overall_impact': overall_impact,
                'stock_impacts': stock_impacts,
                'sentiment_analysis': sentiment_result,
                'investment_signal': investment_signal,
                'risk_level': self.assess_risk_level(overall_impact),
                'confidence_score': self.calculate_confidence_score(stock_impacts, sentiment_result)
            }
            
        except Exception as e:
            logger.error(f"뉴스 영향도 분석 실패: {e}")
            return {}
    
    def analyze_stock_impact(self, stock_code: str, news_data: Dict[str, Any], 
                           sentiment_result: Dict[str, Any]) -> Dict[str, Any]:
        """개별 종목 영향도 분석"""
        try:
            # 종목 기본 정보
            stock_info = self.stock_data_service.get_stock_info(stock_code)
            
            # 뉴스 관련성 점수
            relevance_score = self.calculate_relevance_score(stock_code, news_data)
            
            # 감정 영향도
            sentiment_impact = self.calculate_sentiment_impact(sentiment_result)
            
            # 시장 상황 고려
            market_context = self.get_market_context(stock_code)
            
            # 종합 영향도 계산
            total_impact = (relevance_score * 0.4 + 
                          sentiment_impact * 0.4 + 
                          market_context * 0.2)
            
            return {
                'stock_code': stock_code,
                'stock_name': stock_info.get('name', ''),
                'relevance_score': relevance_score,
                'sentiment_impact': sentiment_impact,
                'market_context': market_context,
                'total_impact': total_impact,
                'expected_price_change': self.predict_price_change(total_impact, sentiment_result),
                'confidence': self.calculate_stock_confidence(relevance_score, sentiment_impact)
            }
            
        except Exception as e:
            logger.error(f"종목 영향도 분석 실패 ({stock_code}): {e}")
            return {}
    
    def calculate_relevance_score(self, stock_code: str, news_data: Dict[str, Any]) -> float:
        """뉴스 관련성 점수 계산"""
        text = f"{news_data['title']} {news_data['content']}"
        
        # 종목명/코드 출현 빈도
        stock_name = self.get_stock_name(stock_code)
        stock_mentions = text.count(stock_code) + text.count(stock_name)
        
        # 키워드 관련성
        keywords = news_data.get('keywords', [])
        keyword_relevance = sum(1 for keyword in keywords if self.is_stock_related(keyword, stock_code))
        
        # 위치 가중치 (제목에 언급된 경우 더 높은 점수)
        title_mentions = news_data['title'].count(stock_code) + news_data['title'].count(stock_name)
        
        # 종합 점수 계산 (0-1)
        total_score = (stock_mentions * 0.5 + keyword_relevance * 0.3 + title_mentions * 0.2)
        normalized_score = min(total_score / 10, 1.0)  # 최대 1.0으로 정규화
        
        return round(normalized_score, 3)
    
    def calculate_sentiment_impact(self, sentiment_result: Dict[str, Any]) -> float:
        """감정 영향도 계산"""
        sentiment_score = sentiment_result.get('sentiment_score', 0.5)
        confidence = sentiment_result.get('confidence', 0.5)
        
        # 감정 점수를 -1에서 1로 변환
        normalized_score = (sentiment_score - 0.5) * 2
        
        # 신뢰도로 가중치 적용
        impact_score = normalized_score * confidence
        
        return round(impact_score, 3)
    
    def predict_price_change(self, impact_score: float, sentiment_result: Dict[str, Any]) -> float:
        """예상 가격 변동률 계산"""
        # 영향도 점수를 가격 변동률로 변환 (-10% ~ +10%)
        base_change = impact_score * 10
        
        # 감정 강도에 따른 조정
        sentiment_label = sentiment_result.get('sentiment_label', 'neutral')
        if sentiment_label == 'positive':
            multiplier = 1.2
        elif sentiment_label == 'negative':
            multiplier = 1.2
        else:
            multiplier = 0.8
        
        predicted_change = base_change * multiplier
        
        return round(predicted_change, 2)
    
    def generate_investment_signal(self, overall_impact: float, 
                                 sentiment_result: Dict[str, Any]) -> Dict[str, Any]:
        """투자 신호 생성"""
        sentiment_label = sentiment_result.get('sentiment_label', 'neutral')
        impact_threshold = 0.3
        
        if abs(overall_impact) < impact_threshold:
            signal = 'HOLD'
            reason = '뉴스 영향도가 낮습니다'
        elif overall_impact > impact_threshold and sentiment_label == 'positive':
            signal = 'BUY'
            reason = '긍정적인 뉴스 영향'
        elif overall_impact < -impact_threshold and sentiment_label == 'negative':
            signal = 'SELL'
            reason = '부정적인 뉴스 영향'
        else:
            signal = 'HOLD'
            reason = '혼조세 또는 중립적 영향'
        
        return {
            'signal': signal,
            'reason': reason,
            'impact_score': overall_impact,
            'sentiment': sentiment_label,
            'confidence': sentiment_result.get('confidence', 0)
        }
```

## 📊 데이터베이스 구조

### 뉴스 관련 테이블
```sql
CREATE TABLE news_articles (
    id SERIAL PRIMARY KEY,
    title VARCHAR(500) NOT NULL,
    content TEXT NOT NULL,
    url VARCHAR(500) UNIQUE NOT NULL,
    source VARCHAR(50) NOT NULL,
    category VARCHAR(50) NOT NULL,
    published_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE news_sentiment (
    id SERIAL PRIMARY KEY,
    news_id INTEGER REFERENCES news_articles(id),
    sentiment_score DECIMAL(3,2) NOT NULL,
    sentiment_label VARCHAR(20) NOT NULL,
    confidence_score DECIMAL(3,2) NOT NULL,
    positive_keywords JSONB,
    negative_keywords JSONB,
    neutral_keywords JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE news_impact (
    id SERIAL PRIMARY KEY,
    news_id INTEGER REFERENCES news_articles(id),
    stock_code VARCHAR(10) NOT NULL,
    relevance_score DECIMAL(3,2) NOT NULL,
    sentiment_impact DECIMAL(3,2) NOT NULL,
    market_context DECIMAL(3,2) NOT NULL,
    total_impact DECIMAL(3,2) NOT NULL,
    expected_price_change DECIMAL(5,2),
    confidence_score DECIMAL(3,2) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE news_keywords (
    id SERIAL PRIMARY KEY,
    news_id INTEGER REFERENCES news_articles(id),
    keyword VARCHAR(100) NOT NULL,
    frequency INTEGER DEFAULT 1,
    importance_score DECIMAL(3,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE news_categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT,
    priority INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 🔄 실시간 뉴스 처리

### 뉴스 스트리밍 시스템
```python
# web/services/news_streaming_service.py
class NewsStreamingService:
    def __init__(self):
        self.websocket_manager = WebSocketManager()
        self.news_queue = Queue()
        self.processing_thread = None
    
    def start_streaming(self):
        """뉴스 스트리밍 시작"""
        self.processing_thread = Thread(target=self.process_news_stream)
        self.processing_thread.daemon = True
        self.processing_thread.start()
    
    def process_news_stream(self):
        """뉴스 스트림 처리"""
        while True:
            try:
                # 새로운 뉴스 확인
                new_news = self.check_for_new_news()
                
                for news in new_news:
                    # 실시간 처리
                    processed_news = self.process_news_realtime(news)
                    
                    # 실시간 브로드캐스트
                    self.broadcast_news(processed_news)
                    
                    # 큐에 추가
                    self.news_queue.put(processed_news)
                
                time.sleep(30)  # 30초마다 확인
                
            except Exception as e:
                logger.error(f"뉴스 스트리밍 처리 실패: {e}")
                time.sleep(60)  # 오류 시 1분 대기
    
    def process_news_realtime(self, news_data: Dict[str, Any]) -> Dict[str, Any]:
        """실시간 뉴스 처리"""
        try:
            # 기본 정보 추가
            processed_news = {
                'id': str(uuid.uuid4()),
                'title': news_data['title'],
                'content': news_data['content'][:200] + '...' if len(news_data['content']) > 200 else news_data['content'],
                'url': news_data['url'],
                'source': news_data['source'],
                'published_at': news_data['published_at'],
                'category': news_data['category'],
                'is_breaking': self.is_breaking_news(news_data),
                'processed_at': datetime.now().isoformat()
            }
            
            # 감정 분석
            sentiment_service = SentimentAnalysisService()
            sentiment_result = sentiment_service.analyze_news_sentiment(news_data)
            processed_news['sentiment'] = sentiment_result
            
            # 영향도 분석
            impact_service = NewsImpactService()
            impact_result = impact_service.analyze_news_impact(news_data)
            processed_news['impact'] = impact_result
            
            return processed_news
            
        except Exception as e:
            logger.error(f"실시간 뉴스 처리 실패: {e}")
            return news_data
    
    def broadcast_news(self, news_data: Dict[str, Any]):
        """뉴스 브로드캐스트"""
        try:
            message = {
                'type': 'news_update',
                'data': news_data,
                'timestamp': datetime.now().isoformat()
            }
            
            self.websocket_manager.broadcast(message)
            
        except Exception as e:
            logger.error(f"뉴스 브로드캐스트 실패: {e}")
    
    def is_breaking_news(self, news_data: Dict[str, Any]) -> bool:
        """긴급 뉴스 판별"""
        breaking_keywords = ['긴급', '속보', 'BREAKING', 'URGENT', '긴급속보']
        title = news_data['title'].lower()
        
        return any(keyword.lower() in title for keyword in breaking_keywords)
```

## 🔐 보안 및 검증

### 뉴스 데이터 검증
```python
# web/services/news_validation_service.py
class NewsValidationService:
    def __init__(self):
        self.spam_filters = self.load_spam_filters()
        self.content_filters = self.load_content_filters()
    
    def validate_news_article(self, news_data: Dict[str, Any]) -> Dict[str, Any]:
        """뉴스 기사 검증"""
        try:
            validation_result = {
                'is_valid': True,
                'warnings': [],
                'errors': []
            }
            
            # 기본 필드 검증
            if not self.validate_required_fields(news_data):
                validation_result['is_valid'] = False
                validation_result['errors'].append('필수 필드가 누락되었습니다')
            
            # 스팸 필터링
            if self.is_spam_news(news_data):
                validation_result['is_valid'] = False
                validation_result['errors'].append('스팸으로 분류된 뉴스입니다')
            
            # 내용 품질 검증
            quality_score = self.assess_content_quality(news_data)
            if quality_score < 0.5:
                validation_result['warnings'].append('뉴스 품질이 낮습니다')
            
            # 중복 검사
            if self.is_duplicate_news(news_data):
                validation_result['warnings'].append('중복된 뉴스입니다')
            
            return validation_result
            
        except Exception as e:
            logger.error(f"뉴스 검증 실패: {e}")
            return {
                'is_valid': False,
                'errors': [f'검증 중 오류가 발생했습니다: {str(e)}']
            }
    
    def validate_required_fields(self, news_data: Dict[str, Any]) -> bool:
        """필수 필드 검증"""
        required_fields = ['title', 'content', 'url', 'source']
        
        for field in required_fields:
            if field not in news_data or not news_data[field]:
                return False
        
        return True
    
    def is_spam_news(self, news_data: Dict[str, Any]) -> bool:
        """스팸 뉴스 판별"""
        text = f"{news_data['title']} {news_data['content']}"
        
        # 스팸 키워드 검사
        spam_keywords = ['광고', '홍보', '이벤트', '할인', '무료']
        spam_count = sum(1 for keyword in spam_keywords if keyword in text)
        
        # 스팸 비율 계산
        spam_ratio = spam_count / len(text.split())
        
        return spam_ratio > 0.1  # 10% 이상이면 스팸으로 분류
    
    def assess_content_quality(self, news_data: Dict[str, Any]) -> float:
        """뉴스 품질 평가"""
        text = f"{news_data['title']} {news_data['content']}"
        
        # 길이 점수
        length_score = min(len(text) / 1000, 1.0)
        
        # 키워드 다양성 점수
        words = text.split()
        unique_words = set(words)
        diversity_score = len(unique_words) / len(words) if words else 0
        
        # 문장 구조 점수
        sentences = text.split('.')
        structure_score = len([s for s in sentences if len(s.split()) > 5]) / len(sentences) if sentences else 0
        
        # 종합 품질 점수
        quality_score = (length_score * 0.4 + diversity_score * 0.3 + structure_score * 0.3)
        
        return round(quality_score, 3)
```

## 📈 성능 최적화

### 뉴스 캐싱 시스템
```python
# web/services/news_cache_service.py
class NewsCacheService:
    def __init__(self):
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
    
    def cache_news_data(self, news_data: List[Dict[str, Any]]):
        """뉴스 데이터 캐싱"""
        try:
            cache_key = "latest_news"
            self.redis_client.setex(cache_key, 1800, json.dumps(news_data))  # 30분
            
            # 개별 뉴스 캐싱
            for news in news_data:
                news_key = f"news:{news.get('id', '')}"
                self.redis_client.setex(news_key, 3600, json.dumps(news))  # 1시간
                
        except Exception as e:
            logger.error(f"뉴스 캐싱 실패: {e}")
    
    def get_cached_news(self, limit: int = 50) -> List[Dict[str, Any]]:
        """캐시된 뉴스 조회"""
        try:
            cache_key = "latest_news"
            cached_data = self.redis_client.get(cache_key)
            
            if cached_data:
                news_list = json.loads(cached_data)
                return news_list[:limit]
            
            return []
            
        except Exception as e:
            logger.error(f"캐시된 뉴스 조회 실패: {e}")
            return []
    
    def cache_sentiment_analysis(self, news_id: str, sentiment_data: Dict[str, Any]):
        """감정 분석 결과 캐싱"""
        try:
            cache_key = f"sentiment:{news_id}"
            self.redis_client.setex(cache_key, 7200, json.dumps(sentiment_data))  # 2시간
            
        except Exception as e:
            logger.error(f"감정 분석 캐싱 실패: {e}")
```

## 🧪 테스트 전략

### 단위 테스트
```python
# tests/test_news_collection_service.py
import pytest
from web.services.news_collection_service import NewsCollectionService

class TestNewsCollectionService:
    def test_collect_real_time_news(self):
        """실시간 뉴스 수집 테스트"""
        service = NewsCollectionService()
        
        news_list = service.collect_real_time_news()
        
        assert isinstance(news_list, list)
        if news_list:
            assert 'title' in news_list[0]
            assert 'content' in news_list[0]
            assert 'url' in news_list[0]
            assert 'source' in news_list[0]
    
    def test_process_news(self):
        """뉴스 처리 테스트"""
        service = NewsCollectionService()
        
        raw_news = [{
            'title': '삼성전자 실적 발표',
            'content': '삼성전자가 좋은 실적을 발표했습니다.',
            'url': 'https://example.com/news1',
            'published_at': '2024-01-01T10:00:00Z'
        }]
        
        processed_news = service.process_news(raw_news, 'test_source')
        
        assert len(processed_news) > 0
        assert processed_news[0]['category'] == 'earnings'
        assert '005930' in processed_news[0]['related_stocks']
```

## 🚀 배포 및 운영

### 환경 설정
```python
# web/config/news_config.py
class NewsConfig:
    # 뉴스 수집 설정
    NEWS_UPDATE_INTERVAL = 300  # 5분
    MAX_NEWS_PER_UPDATE = 100
    NEWS_RETENTION_DAYS = 30
    
    # 감정 분석 설정
    SENTIMENT_CONFIDENCE_THRESHOLD = 0.7
    SENTIMENT_UPDATE_INTERVAL = 600  # 10분
    
    # 캐시 설정
    NEWS_CACHE_TTL = 1800  # 30분
    SENTIMENT_CACHE_TTL = 7200  # 2시간
    
    # API 설정
    NEWS_API_KEYS = {
        'naver': os.environ.get('NAVER_NEWS_API_KEY'),
        'yahoo': os.environ.get('YAHOO_FINANCE_API_KEY'),
        'reuters': os.environ.get('REUTERS_API_KEY')
    }
    
    # 필터링 설정
    SPAM_THRESHOLD = 0.1
    QUALITY_THRESHOLD = 0.5
    DUPLICATE_SIMILARITY_THRESHOLD = 0.8
```

## 📊 분석 및 개선

### 뉴스 성능 분석
```python
# web/services/news_analytics_service.py
class NewsAnalyticsService:
    def analyze_news_performance(self) -> Dict[str, Any]:
        """뉴스 성능 분석"""
        return {
            'collection_stats': self.get_collection_stats(),
            'sentiment_trends': self.analyze_sentiment_trends(),
            'impact_analysis': self.analyze_impact_performance(),
            'user_engagement': self.calculate_user_engagement()
        }
    
    def get_collection_stats(self) -> Dict[str, Any]:
        """뉴스 수집 통계"""
        query = """
            SELECT 
                source,
                COUNT(*) as article_count,
                AVG(sentiment_score) as avg_sentiment,
                COUNT(CASE WHEN sentiment_label = 'positive' THEN 1 END) as positive_count,
                COUNT(CASE WHEN sentiment_label = 'negative' THEN 1 END) as negative_count
            FROM news_articles na
            JOIN news_sentiment ns ON na.id = ns.news_id
            WHERE na.created_at >= CURRENT_DATE - INTERVAL '7 days'
            GROUP BY source
        """
        
        results = self.db.execute(query)
        
        stats = {}
        for row in results:
            stats[row['source']] = {
                'article_count': row['article_count'],
                'avg_sentiment': row['avg_sentiment'],
                'positive_ratio': row['positive_count'] / row['article_count'] if row['article_count'] > 0 else 0,
                'negative_ratio': row['negative_count'] / row['article_count'] if row['article_count'] > 0 else 0
            }
        
        return stats
```

## 🔄 향후 개선 계획

### 단기 개선사항 (1-2개월)
1. **실시간 번역** 기능 추가
2. **뉴스 요약** AI 생성
3. **개인화된 뉴스** 추천
4. **뉴스 알림** 시스템

### 중기 개선사항 (3-6개월)
1. **멀티미디어 뉴스** 지원
2. **뉴스 소스 신뢰도** 평가
3. **뉴스 트렌드** 분석
4. **뉴스 기반 포트폴리오** 최적화

### 장기 개선사항 (6개월 이상)
1. **AI 뉴스 생성** 시스템
2. **뉴스 예측** 모델
3. **글로벌 뉴스** 통합
4. **뉴스 기반 자동 거래** 시스템

## 📚 참고 자료

### 기술 스택
- **프론트엔드**: HTML5, CSS3, JavaScript (ES6+)
- **백엔드**: Python Flask
- **AI/ML**: OpenAI GPT, TensorFlow, scikit-learn
- **데이터베이스**: PostgreSQL, Redis
- **실시간 통신**: WebSocket, Socket.IO
- **텍스트 분석**: KoNLPy, NLTK

### 라이브러리 및 도구
- **뉴스 수집**: BeautifulSoup, Scrapy
- **감정 분석**: VADER, TextBlob
- **텍스트 처리**: spaCy, Transformers
- **시각화**: Chart.js, D3.js
- **테스트**: pytest, Selenium
- **모니터링**: Prometheus, Grafana

이 문서는 Pixie 투자챗봇의 뉴스/이슈 시스템 개발 과정과 기술적 세부사항을 상세히 다루고 있습니다. 지속적인 뉴스 품질 향상과 분석 정확도 개선을 통해 투자자에게 더욱 유용한 정보를 제공하는 것이 목표입니다. 