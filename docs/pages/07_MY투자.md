# Pixie MY 투자 (My Investment)

## 개요
MY 투자 페이지는 사용자의 투자 포트폴리오를 종합적으로 관리하고 분석하는 개인 투자 관리 허브입니다. 실시간 수익률 추적, 리스크 분석, 리밸런싱 제안, 투자 히스토리 관리 등 포괄적인 포트폴리오 관리 기능을 제공합니다.

## 페이지 구조

### 1. 메인 대시보드 (`/my-investment`)
```
헤더: "MY 투자 포트폴리오"
서브헤더: "실시간 투자 현황과 성과 분석"
주요 섹션:
- 포트폴리오 요약
- 자산 구성 현황
- 수익률 차트
- 보유 종목 리스트
- 거래 내역
- 투자 성과 분석
```

## 포트폴리오 관리 시스템

### 1. 포트폴리오 데이터 구조
```python
class Portfolio:
    def __init__(self, user_id):
        self.user_id = user_id
        self.holdings = {}  # {ticker: holding_info}
        self.cash_balance = 0
        self.total_invested = 0
        self.realized_gains = 0
        self.transactions = []
        
    def add_position(self, ticker, quantity, price, date):
        """포지션 추가"""
        if ticker not in self.holdings:
            self.holdings[ticker] = {
                'quantity': 0,
                'avg_price': 0,
                'total_cost': 0,
                'first_purchase': date
            }
        
        holding = self.holdings[ticker]
        total_cost = holding['total_cost'] + (quantity * price)
        total_quantity = holding['quantity'] + quantity
        
        holding['quantity'] = total_quantity
        holding['avg_price'] = total_cost / total_quantity
        holding['total_cost'] = total_cost
        holding['last_update'] = date
        
        # 거래 기록
        self.transactions.append({
            'type': 'BUY',
            'ticker': ticker,
            'quantity': quantity,
            'price': price,
            'total': quantity * price,
            'date': date,
            'balance_after': self.cash_balance
        })
        
        self.total_invested += quantity * price
```

### 2. 실시간 포트폴리오 평가
```python
class PortfolioValuation:
    def __init__(self, portfolio):
        self.portfolio = portfolio
        self.market_data = MarketDataFeed()
        
    def calculate_current_value(self):
        """현재 포트폴리오 가치 계산"""
        total_value = self.portfolio.cash_balance
        holdings_value = {}
        
        for ticker, holding in self.portfolio.holdings.items():
            current_price = self.market_data.get_current_price(ticker)
            market_value = holding['quantity'] * current_price
            
            holdings_value[ticker] = {
                'quantity': holding['quantity'],
                'avg_price': holding['avg_price'],
                'current_price': current_price,
                'market_value': market_value,
                'unrealized_gain': market_value - holding['total_cost'],
                'return_rate': (current_price - holding['avg_price']) / holding['avg_price']
            }
            
            total_value += market_value
        
        return {
            'total_value': total_value,
            'holdings_value': holdings_value,
            'cash': self.portfolio.cash_balance,
            'total_return': (total_value - self.portfolio.total_invested) / self.portfolio.total_invested,
            'timestamp': datetime.now()
        }
```

## 포트폴리오 분석 기능

### 1. 자산 배분 분석
```python
class AssetAllocationAnalyzer:
    def analyze_allocation(self, portfolio):
        """자산 배분 현황 분석"""
        current_value = portfolio.calculate_current_value()
        total_value = current_value['total_value']
        
        # 자산군별 분류
        allocation = {
            'stocks': {'domestic': 0, 'international': 0},
            'bonds': 0,
            'etf': 0,
            'cash': current_value['cash'],
            'alternative': 0
        }
        
        # 섹터별 분류
        sector_allocation = defaultdict(float)
        
        # 지역별 분류
        geographic_allocation = {
            'korea': 0,
            'usa': 0,
            'europe': 0,
            'asia': 0,
            'other': 0
        }
        
        for ticker, holding in current_value['holdings_value'].items():
            stock_info = self.get_stock_info(ticker)
            
            # 자산군 분류
            if stock_info['type'] == 'stock':
                if stock_info['market'] in ['KOSPI', 'KOSDAQ']:
                    allocation['stocks']['domestic'] += holding['market_value']
                    geographic_allocation['korea'] += holding['market_value']
                else:
                    allocation['stocks']['international'] += holding['market_value']
                    geographic_allocation[stock_info['region']] += holding['market_value']
            elif stock_info['type'] == 'etf':
                allocation['etf'] += holding['market_value']
            
            # 섹터 분류
            sector_allocation[stock_info['sector']] += holding['market_value']
        
        # 비중 계산
        allocation_percentages = {
            k: (v / total_value * 100 if isinstance(v, (int, float)) 
                else {k2: v2 / total_value * 100 for k2, v2 in v.items()})
            for k, v in allocation.items()
        }
        
        sector_percentages = {
            sector: value / total_value * 100 
            for sector, value in sector_allocation.items()
        }
        
        return {
            'asset_allocation': allocation_percentages,
            'sector_allocation': sector_percentages,
            'geographic_allocation': {
                k: v / total_value * 100 
                for k, v in geographic_allocation.items()
            },
            'diversification_score': self.calculate_diversification_score(allocation_percentages)
        }
```

### 2. 리스크 분석
```python
class RiskAnalyzer:
    def __init__(self):
        self.risk_free_rate = 0.035  # 3.5% 무위험 수익률
        
    def analyze_portfolio_risk(self, portfolio, lookback_days=252):
        """포트폴리오 리스크 분석"""
        
        # 일별 수익률 데이터 수집
        returns = self.get_historical_returns(portfolio, lookback_days)
        
        # 기본 리스크 지표
        volatility = np.std(returns) * np.sqrt(252)  # 연환산 변동성
        
        # VaR (Value at Risk) - 95% 신뢰수준
        var_95 = np.percentile(returns, 5)
        
        # CVaR (Conditional VaR)
        cvar_95 = returns[returns <= var_95].mean()
        
        # 최대 낙폭 (Maximum Drawdown)
        cumulative_returns = (1 + returns).cumprod()
        running_max = cumulative_returns.cummax()
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = drawdown.min()
        
        # 샤프 비율
        excess_returns = returns.mean() - self.risk_free_rate / 252
        sharpe_ratio = excess_returns / returns.std() * np.sqrt(252)
        
        # 소르티노 비율 (하방 리스크만 고려)
        downside_returns = returns[returns < 0]
        downside_deviation = np.std(downside_returns) * np.sqrt(252)
        sortino_ratio = excess_returns / downside_deviation * np.sqrt(252)
        
        # 베타 계산 (KOSPI 대비)
        market_returns = self.get_market_returns('KOSPI', lookback_days)
        covariance = np.cov(returns, market_returns)[0, 1]
        market_variance = np.var(market_returns)
        beta = covariance / market_variance
        
        # 리스크 등급 평가
        risk_grade = self.evaluate_risk_grade(volatility, max_drawdown, beta)
        
        return {
            'volatility': volatility,
            'var_95': var_95,
            'cvar_95': cvar_95,
            'max_drawdown': max_drawdown,
            'sharpe_ratio': sharpe_ratio,
            'sortino_ratio': sortino_ratio,
            'beta': beta,
            'risk_grade': risk_grade,
            'risk_score': self.calculate_risk_score(volatility, max_drawdown, beta)
        }
    
    def stress_test(self, portfolio, scenarios):
        """스트레스 테스트"""
        results = []
        
        scenarios_config = {
            '금융위기': {'market': -40, 'volatility': 3.0},
            '금리 급등': {'bonds': -15, 'stocks': -10},
            '경기 침체': {'stocks': -25, 'commodities': -20},
            '인플레이션': {'bonds': -20, 'cash': -10}
        }
        
        for scenario_name, shocks in scenarios_config.items():
            shocked_value = self.apply_shocks(portfolio, shocks)
            loss = portfolio.current_value - shocked_value
            loss_rate = loss / portfolio.current_value
            
            results.append({
                'scenario': scenario_name,
                'shocked_value': shocked_value,
                'loss': loss,
                'loss_rate': loss_rate
            })
        
        return results
```

### 3. 성과 분석
```python
class PerformanceAnalyzer:
    def analyze_performance(self, portfolio):
        """투자 성과 상세 분석"""
        
        # 기간별 수익률
        returns = {
            '1d': self.calculate_period_return(portfolio, 1),
            '1w': self.calculate_period_return(portfolio, 7),
            '1m': self.calculate_period_return(portfolio, 30),
            '3m': self.calculate_period_return(portfolio, 90),
            '6m': self.calculate_period_return(portfolio, 180),
            '1y': self.calculate_period_return(portfolio, 365),
            'ytd': self.calculate_ytd_return(portfolio),
            'all': self.calculate_total_return(portfolio)
        }
        
        # 벤치마크 대비 성과
        benchmarks = {
            'KOSPI': self.get_benchmark_return('KOSPI'),
            'KOSDAQ': self.get_benchmark_return('KOSDAQ'),
            'S&P500': self.get_benchmark_return('S&P500')
        }
        
        # 알파 계산
        alpha = returns['1y'] - (self.risk_free_rate + 
                portfolio.beta * (benchmarks['KOSPI'] - self.risk_free_rate))
        
        # 정보 비율 (Information Ratio)
        tracking_error = self.calculate_tracking_error(portfolio, 'KOSPI')
        information_ratio = (returns['1y'] - benchmarks['KOSPI']) / tracking_error
        
        # 승률 분석
        winning_trades = [t for t in portfolio.transactions 
                         if t['realized_gain'] > 0]
        losing_trades = [t for t in portfolio.transactions 
                        if t['realized_gain'] < 0]
        
        win_rate = len(winning_trades) / len(portfolio.transactions)
        avg_win = np.mean([t['realized_gain'] for t in winning_trades])
        avg_loss = np.mean([abs(t['realized_gain']) for t in losing_trades])
        profit_factor = (avg_win * len(winning_trades)) / (avg_loss * len(losing_trades))
        
        return {
            'returns': returns,
            'benchmarks': benchmarks,
            'alpha': alpha,
            'information_ratio': information_ratio,
            'win_rate': win_rate,
            'avg_win': avg_win,
            'avg_loss': avg_loss,
            'profit_factor': profit_factor,
            'best_performer': self.get_best_performer(portfolio),
            'worst_performer': self.get_worst_performer(portfolio)
        }
```

## 리밸런싱 시스템

### 1. 자동 리밸런싱 제안
```python
class PortfolioRebalancer:
    def __init__(self):
        self.optimizer = PortfolioOptimizer()
        
    def suggest_rebalancing(self, portfolio, target_allocation):
        """리밸런싱 제안 생성"""
        current_allocation = portfolio.get_current_allocation()
        
        # 목표 대비 편차 계산
        deviations = {}
        for asset, target_weight in target_allocation.items():
            current_weight = current_allocation.get(asset, 0)
            deviations[asset] = target_weight - current_weight
        
        # 리밸런싱 필요 여부 판단 (5% 이상 편차)
        needs_rebalancing = any(abs(dev) > 0.05 for dev in deviations.values())
        
        if not needs_rebalancing:
            return {'needed': False, 'message': '리밸런싱이 필요하지 않습니다.'}
        
        # 구체적인 매매 제안 생성
        trades = []
        total_value = portfolio.get_total_value()
        
        for asset, deviation in sorted(deviations.items(), 
                                      key=lambda x: x[1]):
            if abs(deviation) < 0.01:  # 1% 미만 편차는 무시
                continue
            
            target_value = total_value * target_allocation[asset]
            current_value = total_value * current_allocation.get(asset, 0)
            trade_value = target_value - current_value
            
            if trade_value > 0:
                action = 'BUY'
                shares = self.calculate_shares_to_buy(asset, trade_value)
            else:
                action = 'SELL'
                shares = self.calculate_shares_to_sell(asset, abs(trade_value))
            
            trades.append({
                'action': action,
                'asset': asset,
                'shares': shares,
                'value': abs(trade_value),
                'reason': f'목표 비중 {target_allocation[asset]:.1%} 달성'
            })
        
        # 거래 비용 고려
        transaction_cost = self.estimate_transaction_costs(trades)
        
        # 세금 영향 분석
        tax_impact = self.calculate_tax_impact(portfolio, trades)
        
        return {
            'needed': True,
            'trades': trades,
            'transaction_cost': transaction_cost,
            'tax_impact': tax_impact,
            'expected_improvement': self.calculate_expected_improvement(
                portfolio, target_allocation
            )
        }
```

### 2. 최적 포트폴리오 구성
```python
class PortfolioOptimizer:
    def optimize_portfolio(self, user_profile, market_conditions):
        """마코위츠 포트폴리오 최적화"""
        
        # 투자 가능 자산 선정
        universe = self.select_investment_universe(user_profile)
        
        # 기대 수익률 계산
        expected_returns = self.calculate_expected_returns(universe)
        
        # 공분산 행렬 계산
        cov_matrix = self.calculate_covariance_matrix(universe)
        
        # 최적화 문제 설정
        def objective(weights):
            portfolio_return = np.sum(weights * expected_returns)
            portfolio_volatility = np.sqrt(
                np.dot(weights.T, np.dot(cov_matrix, weights))
            )
            sharpe_ratio = (portfolio_return - self.risk_free_rate) / portfolio_volatility
            return -sharpe_ratio  # 최대화를 위해 음수
        
        # 제약 조건
        constraints = [
            {'type': 'eq', 'fun': lambda x: np.sum(x) - 1},  # 비중 합 = 1
        ]
        
        # 경계 조건 (각 자산 0-30%)
        bounds = [(0, 0.3) for _ in universe]
        
        # 최적화 실행
        initial_weights = np.array([1/len(universe)] * len(universe))
        result = minimize(objective, initial_weights, 
                         method='SLSQP', bounds=bounds, 
                         constraints=constraints)
        
        optimal_weights = result.x
        
        # 결과 정리
        optimal_portfolio = {
            universe[i]: weight 
            for i, weight in enumerate(optimal_weights)
            if weight > 0.01  # 1% 이상만 포함
        }
        
        # 성과 예측
        expected_performance = {
            'expected_return': np.sum(optimal_weights * expected_returns),
            'expected_volatility': np.sqrt(
                np.dot(optimal_weights.T, np.dot(cov_matrix, optimal_weights))
            ),
            'expected_sharpe': -result.fun
        }
        
        return {
            'optimal_weights': optimal_portfolio,
            'expected_performance': expected_performance,
            'risk_level': user_profile['risk_tolerance']
        }
```

## 거래 관리 시스템

### 1. 거래 기록 및 추적
```python
class TransactionManager:
    def record_transaction(self, portfolio_id, transaction):
        """거래 기록"""
        transaction_record = {
            'id': str(uuid.uuid4()),
            'portfolio_id': portfolio_id,
            'type': transaction['type'],  # BUY, SELL
            'ticker': transaction['ticker'],
            'quantity': transaction['quantity'],
            'price': transaction['price'],
            'commission': self.calculate_commission(transaction),
            'tax': self.calculate_tax(transaction),
            'total_amount': self.calculate_total_amount(transaction),
            'executed_at': datetime.now(),
            'settlement_date': self.calculate_settlement_date(),
            'notes': transaction.get('notes', '')
        }
        
        # 실현 손익 계산 (매도 시)
        if transaction['type'] == 'SELL':
            realized_gain = self.calculate_realized_gain(
                portfolio_id, 
                transaction
            )
            transaction_record['realized_gain'] = realized_gain
            transaction_record['tax_on_gain'] = self.calculate_capital_gains_tax(
                realized_gain
            )
        
        # DB 저장
        self.save_transaction(transaction_record)
        
        # 포트폴리오 업데이트
        self.update_portfolio(portfolio_id, transaction_record)
        
        return transaction_record
```

### 2. 세금 최적화
```python
class TaxOptimizer:
    def optimize_tax_strategy(self, portfolio):
        """세금 최적화 전략"""
        
        strategies = []
        
        # 1. 손실 실현을 통한 세금 절감 (Tax Loss Harvesting)
        losing_positions = [
            (ticker, holding) 
            for ticker, holding in portfolio.holdings.items()
            if holding['unrealized_gain'] < 0
        ]
        
        if losing_positions:
            tax_savings = sum(
                abs(holding['unrealized_gain']) * 0.154  # 양도세 15.4%
                for _, holding in losing_positions
            )
            
            strategies.append({
                'strategy': 'tax_loss_harvesting',
                'description': '손실 종목 매도를 통한 세금 절감',
                'positions': losing_positions,
                'estimated_savings': tax_savings
            })
        
        # 2. 장기 보유 전략 (1년 이상 보유 시 세제 혜택)
        short_term_positions = [
            (ticker, holding)
            for ticker, holding in portfolio.holdings.items()
            if (datetime.now() - holding['first_purchase']).days < 365
        ]
        
        if short_term_positions:
            strategies.append({
                'strategy': 'hold_for_long_term',
                'description': '장기 보유를 통한 세금 절감',
                'positions': short_term_positions,
                'days_to_long_term': [
                    365 - (datetime.now() - h['first_purchase']).days
                    for _, h in short_term_positions
                ]
            })
        
        # 3. 배당 소득 최적화
        dividend_optimization = self.optimize_dividend_income(portfolio)
        if dividend_optimization:
            strategies.append(dividend_optimization)
        
        return strategies
```

## 투자 일지 시스템

### 1. 자동 투자 일지 생성
```python
class InvestmentJournal:
    def __init__(self, portfolio_id):
        self.portfolio_id = portfolio_id
        self.entries = []
        
    def create_entry(self, action, details):
        """투자 일지 항목 생성"""
        entry = {
            'id': str(uuid.uuid4()),
            'timestamp': datetime.now(),
            'action': action,
            'details': details,
            'market_context': self.capture_market_context(),
            'portfolio_snapshot': self.capture_portfolio_snapshot(),
            'tags': self.auto_tag(action, details)
        }
        
        # AI 인사이트 추가
        entry['ai_insight'] = self.generate_ai_insight(entry)
        
        self.entries.append(entry)
        self.save_entry(entry)
        
        return entry
    
    def capture_market_context(self):
        """거래 시점의 시장 상황 기록"""
        return {
            'kospi': get_index_value('KOSPI'),
            'kosdaq': get_index_value('KOSDAQ'),
            'usd_krw': get_exchange_rate('USD/KRW'),
            'vix': get_volatility_index(),
            'market_sentiment': analyze_market_sentiment()
        }
    
    def generate_weekly_report(self):
        """주간 투자 리포트 생성"""
        week_entries = self.get_entries_for_period(days=7)
        
        report = {
            'period': f'{datetime.now() - timedelta(days=7)} to {datetime.now()}',
            'summary': {
                'total_trades': len(week_entries),
                'buy_trades': sum(1 for e in week_entries if e['action'] == 'BUY'),
                'sell_trades': sum(1 for e in week_entries if e['action'] == 'SELL'),
                'realized_gains': sum(e.get('realized_gain', 0) for e in week_entries)
            },
            'performance': self.calculate_weekly_performance(),
            'key_decisions': self.extract_key_decisions(week_entries),
            'lessons_learned': self.extract_lessons(week_entries),
            'next_week_plan': self.generate_next_week_plan()
        }
        
        return report
```

## 워치리스트 관리

### 1. 스마트 워치리스트
```python
class Watchlist:
    def __init__(self, user_id):
        self.user_id = user_id
        self.items = []
        
    def add_to_watchlist(self, ticker, reason, alert_rules=None):
        """워치리스트 추가"""
        item = {
            'ticker': ticker,
            'added_date': datetime.now(),
            'reason': reason,
            'initial_price': get_current_price(ticker),
            'alert_rules': alert_rules or [],
            'notes': [],
            'analysis': self.analyze_stock(ticker)
        }
        
        self.items.append(item)
        
        # 알림 규칙 설정
        if alert_rules:
            self.setup_alerts(ticker, alert_rules)
        
        return item
    
    def analyze_stock(self, ticker):
        """종목 자동 분석"""
        return {
            'valuation': analyze_valuation(ticker),
            'technical': analyze_technicals(ticker),
            'sentiment': analyze_news_sentiment(ticker),
            'ai_score': calculate_ai_score(ticker),
            'buy_signals': detect_buy_signals(ticker),
            'risks': identify_risks(ticker)
        }
    
    def monitor_watchlist(self):
        """워치리스트 모니터링"""
        alerts = []
        
        for item in self.items:
            ticker = item['ticker']
            current_price = get_current_price(ticker)
            
            # 가격 변동 체크
            price_change = (current_price - item['initial_price']) / item['initial_price']
            
            # 알림 규칙 체크
            for rule in item['alert_rules']:
                if self.check_alert_condition(ticker, rule):
                    alerts.append({
                        'ticker': ticker,
                        'rule': rule,
                        'message': self.generate_alert_message(ticker, rule),
                        'action_suggested': self.suggest_action(ticker, rule)
                    })
            
            # AI 추천 업데이트
            if abs(price_change) > 0.05:  # 5% 이상 변동
                item['analysis'] = self.analyze_stock(ticker)
                item['ai_recommendation'] = self.get_ai_recommendation(ticker)
        
        return alerts
```

## 포트폴리오 시각화

### 1. 자산 구성 차트
```javascript
// 도넛 차트로 자산 구성 표시
const assetAllocationChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
        labels: ['국내주식', '해외주식', 'ETF', '채권', '현금'],
        datasets: [{
            data: [45, 25, 15, 10, 5],
            backgroundColor: [
                '#FF6384',
                '#36A2EB',
                '#FFCE56',
                '#4BC0C0',
                '#9966FF'
            ]
        }]
    },
    options: {
        responsive: true,
        plugins: {
            legend: {
                position: 'right'
            },
            tooltip: {
                callbacks: {
                    label: function(context) {
                        const label = context.label || '';
                        const value = context.parsed || 0;
                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                        const percentage = ((value / total) * 100).toFixed(1);
                        return `${label}: ${percentage}% (₩${value.toLocaleString()})`;
                    }
                }
            }
        }
    }
});
```

### 2. 수익률 추이 차트
```javascript
// 시계열 수익률 차트
const performanceChart = new Chart(ctx, {
    type: 'line',
    data: {
        labels: dates,
        datasets: [{
            label: '내 포트폴리오',
            data: portfolioReturns,
            borderColor: 'rgb(75, 192, 192)',
            backgroundColor: 'rgba(75, 192, 192, 0.2)',
            tension: 0.1
        }, {
            label: 'KOSPI',
            data: kospiReturns,
            borderColor: 'rgb(255, 99, 132)',
            backgroundColor: 'rgba(255, 99, 132, 0.2)',
            borderDash: [5, 5],
            tension: 0.1
        }]
    },
    options: {
        responsive: true,
        plugins: {
            title: {
                display: true,
                text: '포트폴리오 수익률 vs KOSPI'
            },
            tooltip: {
                mode: 'index',
                intersect: false
            }
        },
        scales: {
            y: {
                ticks: {
                    callback: function(value) {
                        return value + '%';
                    }
                }
            }
        }
    }
});
```

## MY 투자 페이지 UI

### 1. 포트폴리오 요약 카드
```html
<div class="portfolio-summary-card">
    <h2>포트폴리오 현황</h2>
    
    <div class="value-section">
        <div class="total-value">
            <label>총 평가금액</label>
            <span class="amount">₩25,350,000</span>
        </div>
        
        <div class="daily-change">
            <label>일일 변동</label>
            <span class="change positive">+₩350,000 (+1.4%)</span>
        </div>
    </div>
    
    <div class="metrics-grid">
        <div class="metric">
            <label>총 수익률</label>
            <span class="value positive">+15.3%</span>
        </div>
        <div class="metric">
            <label>실현 손익</label>
            <span class="value positive">+₩1,250,000</span>
        </div>
        <div class="metric">
            <label>평가 손익</label>
            <span class="value positive">+₩2,100,000</span>
        </div>
        <div class="metric">
            <label>보유 종목</label>
            <span class="value">12개</span>
        </div>
    </div>
</div>
```

### 2. 보유 종목 테이블
```html
<table class="holdings-table">
    <thead>
        <tr>
            <th>종목명</th>
            <th>보유수량</th>
            <th>평균단가</th>
            <th>현재가</th>
            <th>평가금액</th>
            <th>수익률</th>
            <th>비중</th>
            <th>액션</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>
                <div class="stock-info">
                    <span class="name">삼성전자</span>
                    <span class="ticker">005930</span>
                </div>
            </td>
            <td>50주</td>
            <td>₩65,000</td>
            <td>₩72,500</td>
            <td>₩3,625,000</td>
            <td class="positive">+11.5%</td>
            <td>14.3%</td>
            <td>
                <button class="btn-sm btn-buy">매수</button>
                <button class="btn-sm btn-sell">매도</button>
            </td>
        </tr>
    </tbody>
</table>
```

## API 엔드포인트

### 1. 포트폴리오 조회
```python
@app.route('/api/portfolio', methods=['GET'])
def get_portfolio():
    """포트폴리오 조회 API"""
    user_id = get_user_id_from_session()
    
    portfolio = Portfolio.get_by_user_id(user_id)
    if not portfolio:
        return jsonify({'error': 'Portfolio not found'}), 404
    
    # 현재 평가액 계산
    valuation = portfolio.calculate_current_value()
    
    # 성과 분석
    performance = PerformanceAnalyzer().analyze_performance(portfolio)
    
    # 리스크 분석
    risk = RiskAnalyzer().analyze_portfolio_risk(portfolio)
    
    return jsonify({
        'portfolio': {
            'total_value': valuation['total_value'],
            'holdings': valuation['holdings_value'],
            'cash': portfolio.cash_balance,
            'total_return': valuation['total_return']
        },
        'performance': performance,
        'risk': risk,
        'updated_at': datetime.now().isoformat()
    })
```

### 2. 거래 실행
```python
@app.route('/api/trade', methods=['POST'])
def execute_trade():
    """거래 실행 API"""
    data = request.json
    user_id = get_user_id_from_session()
    
    # 거래 검증
    validation = validate_trade(data)
    if not validation['valid']:
        return jsonify({'error': validation['message']}), 400
    
    # 거래 실행
    transaction = TransactionManager().record_transaction(
        user_id,
        {
            'type': data['type'],
            'ticker': data['ticker'],
            'quantity': data['quantity'],
            'price': data.get('price') or get_current_price(data['ticker']),
            'notes': data.get('notes', '')
        }
    )
    
    # 포트폴리오 업데이트
    portfolio = Portfolio.get_by_user_id(user_id)
    portfolio.update_with_transaction(transaction)
    
    return jsonify({
        'transaction': transaction,
        'portfolio_value': portfolio.get_total_value(),
        'message': '거래가 성공적으로 실행되었습니다.'
    })
```

## 데이터 저장 구조

### 데이터베이스 스키마
```sql
-- 포트폴리오 테이블
CREATE TABLE portfolios (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 보유 종목 테이블
CREATE TABLE holdings (
    id SERIAL PRIMARY KEY,
    portfolio_id INTEGER REFERENCES portfolios(id),
    ticker VARCHAR(20) NOT NULL,
    quantity INTEGER NOT NULL,
    avg_price DECIMAL(10, 2) NOT NULL,
    total_cost DECIMAL(15, 2) NOT NULL,
    first_purchase DATE NOT NULL,
    last_update TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(portfolio_id, ticker)
);

-- 거래 내역 테이블
CREATE TABLE transactions (
    id SERIAL PRIMARY KEY,
    portfolio_id INTEGER REFERENCES portfolios(id),
    type VARCHAR(10) NOT NULL,  -- BUY, SELL
    ticker VARCHAR(20) NOT NULL,
    quantity INTEGER NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    commission DECIMAL(10, 2),
    tax DECIMAL(10, 2),
    total_amount DECIMAL(15, 2) NOT NULL,
    realized_gain DECIMAL(15, 2),
    executed_at TIMESTAMP NOT NULL,
    notes TEXT
);

-- 워치리스트 테이블
CREATE TABLE watchlist (
    id SERIAL PRIMARY KEY,
    user_id VARCHAR(50) NOT NULL,
    ticker VARCHAR(20) NOT NULL,
    added_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reason TEXT,
    target_price DECIMAL(10, 2),
    stop_loss DECIMAL(10, 2),
    notes TEXT,
    UNIQUE(user_id, ticker)
);

-- 투자 일지 테이블
CREATE TABLE investment_journal (
    id SERIAL PRIMARY KEY,
    portfolio_id INTEGER REFERENCES portfolios(id),
    entry_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    action VARCHAR(50),
    details JSONB,
    market_context JSONB,
    tags TEXT[]
);
```

## 향후 개발 계획

1. **고급 분석 기능**
   - 몬테카를로 시뮬레이션
   - 팩터 분석 (Factor Analysis)
   - 페어 트레이딩 전략
   - 옵션 전략 시뮬레이션

2. **자동화 기능**
   - 자동 매매 시스템
   - 조건부 주문 설정
   - 정기 리밸런싱 자동화
   - 세금 최적화 자동 실행

3. **소셜 기능**
   - 포트폴리오 공유
   - 투자 대회 개최
   - 멘토링 시스템
   - 커뮤니티 인사이트

4. **연동 서비스**
   - 증권사 API 연동
   - 은행 계좌 연동
   - 세무 신고 자동화
   - 재무 설계 통합

5. **모바일 앱**
   - iOS/Android 네이티브 앱
   - 실시간 푸시 알림
   - 생체 인증 보안
   - 오프라인 모드 지원