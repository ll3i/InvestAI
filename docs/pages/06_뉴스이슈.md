# Pixie 뉴스/이슈 (News & Issues)

## 개요
뉴스/이슈 페이지는 실시간 금융 뉴스 수집, AI 기반 감성 분석, 개인화된 뉴스 큐레이션을 제공하는 종합 금융 정보 플랫폼입니다. BERT 기반 자연어 처리와 TF-IDF 벡터화를 활용하여 투자 관련 인사이트를 추출합니다.

## 페이지 구조

### 1. 메인 뉴스 대시보드 (`/news`)
```
헤더: "실시간 금융 뉴스 & 시장 이슈"
서브헤더: "AI가 분석한 오늘의 투자 인사이트"
주요 섹션:
- 헤드라인 뉴스 (Top 5)
- 실시간 뉴스 피드
- 종목별 뉴스
- 감성 분석 현황
- 키워드 트렌드
```

## 뉴스 수집 시스템

### 1. 데이터 소스 및 수집 엔진
```python
class NewsCollector:
    def __init__(self):
        self.sources = {
            'naver_finance': 'https://finance.naver.com/news/news_list.nhn',
            'daum_finance': 'https://finance.daum.net/news',
            'yonhap': 'https://www.yna.co.kr/economy/all',
            'hankyung': 'https://www.hankyung.com/finance',
            'mk': 'https://www.mk.co.kr/news/stock/',
            'edaily': 'https://www.edaily.co.kr/news/stock',
            'reuters_kr': 'https://kr.reuters.com/finance'
        }
        self.rss_feeds = [
            'http://rss.hankyung.com/feed/finance.xml',
            'http://rss.mk.co.kr/rss/30100041.xml',
            'http://rss.edaily.co.kr/stock_news.xml'
        ]
        
    def collect_news(self):
        """멀티소스 뉴스 수집"""
        all_news = []
        
        # RSS 피드 수집
        for feed_url in self.rss_feeds:
            try:
                feed = feedparser.parse(feed_url)
                for entry in feed.entries[:20]:  # 최신 20개
                    news_item = {
                        'title': entry.title,
                        'summary': entry.get('summary', ''),
                        'link': entry.link,
                        'published': entry.get('published_parsed'),
                        'source': feed.feed.title,
                        'category': self.categorize_news(entry.title)
                    }
                    all_news.append(news_item)
            except Exception as e:
                logger.error(f"RSS 수집 오류: {e}")
        
        # 웹 스크래핑 (추가 소스)
        for source_name, url in self.sources.items():
            news = self.scrape_news_site(url, source_name)
            all_news.extend(news)
        
        # 중복 제거 및 정렬
        unique_news = self.remove_duplicates(all_news)
        sorted_news = sorted(unique_news, 
                           key=lambda x: x['published'], 
                           reverse=True)
        
        return sorted_news
```

### 2. 실시간 뉴스 스트리밍
```python
class NewsStreamProcessor:
    def __init__(self):
        self.kafka_consumer = KafkaConsumer(
            'financial-news',
            bootstrap_servers=['localhost:9092'],
            value_deserializer=lambda m: json.loads(m.decode('utf-8'))
        )
        
    async def stream_news(self):
        """실시간 뉴스 스트리밍"""
        async for message in self.kafka_consumer:
            news_data = message.value
            
            # 실시간 처리
            processed = await self.process_news(news_data)
            
            # 웹소켓으로 클라이언트에 전송
            await websocket.send(json.dumps({
                'type': 'news_update',
                'data': processed
            }))
    
    async def process_news(self, news):
        """뉴스 실시간 처리"""
        # 감성 분석
        sentiment = await self.analyze_sentiment(news['content'])
        
        # 관련 종목 추출
        related_stocks = self.extract_stock_mentions(news['content'])
        
        # 중요도 스코어링
        importance = self.calculate_importance(news)
        
        return {
            **news,
            'sentiment': sentiment,
            'related_stocks': related_stocks,
            'importance': importance,
            'processed_at': datetime.now().isoformat()
        }
```

## AI 감성 분석 시스템

### 1. BERT 기반 감성 분석
```python
class NewsSentimentAnalyzer:
    def __init__(self):
        self.tokenizer = BertTokenizer.from_pretrained('klue/bert-base')
        self.model = BertForSequenceClassification.from_pretrained(
            'klue/bert-base',
            num_labels=3  # 긍정, 중립, 부정
        )
        self.model.load_state_dict(torch.load('models/news_sentiment.pt'))
        
    def analyze_sentiment(self, text):
        """뉴스 감성 분석"""
        # 토큰화
        inputs = self.tokenizer(
            text,
            padding=True,
            truncation=True,
            max_length=512,
            return_tensors='pt'
        )
        
        # 예측
        with torch.no_grad():
            outputs = self.model(**inputs)
            predictions = torch.nn.functional.softmax(outputs.logits, dim=-1)
        
        # 감성 점수 계산
        sentiment_scores = {
            'positive': float(predictions[0][0]),
            'neutral': float(predictions[0][1]),
            'negative': float(predictions[0][2])
        }
        
        # 주요 감성 결정
        sentiment = max(sentiment_scores, key=sentiment_scores.get)
        confidence = sentiment_scores[sentiment]
        
        return {
            'sentiment': sentiment,
            'confidence': confidence,
            'scores': sentiment_scores
        }
```

### 2. 이진 분류 감성 분석 (Enhanced)
```python
class BinarySentimentAnalyzer:
    """향상된 이진 분류 시스템"""
    
    def __init__(self):
        self.model = self.load_fine_tuned_model()
        self.keyword_weights = self.load_keyword_weights()
        
    def analyze_binary_sentiment(self, text):
        """긍정/부정 이진 분류"""
        
        # 키워드 기반 초기 분석
        keyword_score = self.keyword_analysis(text)
        
        # 딥러닝 모델 예측
        model_score = self.model_prediction(text)
        
        # 앙상블 결과
        final_score = 0.7 * model_score + 0.3 * keyword_score
        
        return {
            'sentiment': 'positive' if final_score > 0.5 else 'negative',
            'score': final_score,
            'confidence': abs(final_score - 0.5) * 2,
            'keyword_influence': keyword_score,
            'model_influence': model_score
        }
    
    def keyword_analysis(self, text):
        """키워드 기반 감성 점수"""
        positive_keywords = [
            '상승', '급등', '신고가', '호재', '성장', '개선', '증가',
            '흑자', '수혜', '기대', '호조', '강세', '돌파', '회복'
        ]
        negative_keywords = [
            '하락', '급락', '신저가', '악재', '위축', '악화', '감소',
            '적자', '피해', '우려', '부진', '약세', '이탈', '침체'
        ]
        
        pos_count = sum(1 for word in positive_keywords if word in text)
        neg_count = sum(1 for word in negative_keywords if word in text)
        
        if pos_count + neg_count == 0:
            return 0.5
        
        return pos_count / (pos_count + neg_count)
```

## 뉴스 분류 및 태깅

### 1. 카테고리 분류 시스템
```python
class NewsClassifier:
    def __init__(self):
        self.categories = {
            'market': ['코스피', '코스닥', '지수', '시황', '장마감'],
            'company': ['실적', '공시', '인수', '합병', 'M&A'],
            'sector': ['반도체', '바이오', '배터리', '자동차', 'IT'],
            'economy': ['금리', '환율', 'GDP', '물가', '부동산'],
            'global': ['미국', '중국', '유럽', 'Fed', 'ECB'],
            'crypto': ['비트코인', '이더리움', '암호화폐', '가상자산'],
            'commodity': ['원유', '금', '구리', '원자재', '곡물']
        }
        
    def classify_news(self, title, content):
        """뉴스 카테고리 분류"""
        text = title + " " + content
        
        category_scores = {}
        for category, keywords in self.categories.items():
            score = sum(1 for keyword in keywords if keyword in text)
            category_scores[category] = score
        
        # 상위 카테고리 선택
        primary_category = max(category_scores, key=category_scores.get)
        
        # 멀티 카테고리 (점수 > 0인 모든 카테고리)
        all_categories = [cat for cat, score in category_scores.items() 
                         if score > 0]
        
        return {
            'primary': primary_category,
            'all': all_categories,
            'scores': category_scores
        }
```

### 2. 관련 종목 추출
```python
class StockMentionExtractor:
    def __init__(self):
        self.stock_dict = self.load_stock_dictionary()
        self.company_patterns = self.compile_patterns()
        
    def extract_mentions(self, text):
        """뉴스에서 종목 언급 추출"""
        mentioned_stocks = []
        
        # 정규표현식으로 종목코드 추출
        ticker_pattern = r'\((\d{6})\)'
        tickers = re.findall(ticker_pattern, text)
        
        for ticker in tickers:
            if ticker in self.stock_dict:
                mentioned_stocks.append({
                    'ticker': ticker,
                    'name': self.stock_dict[ticker]['name'],
                    'market': self.stock_dict[ticker]['market']
                })
        
        # 회사명으로 추출
        for company, info in self.stock_dict.items():
            if info['name'] in text:
                if not any(s['ticker'] == company for s in mentioned_stocks):
                    mentioned_stocks.append({
                        'ticker': company,
                        'name': info['name'],
                        'market': info['market']
                    })
        
        return mentioned_stocks
```

## 개인화 뉴스 큐레이션

### 1. 사용자 관심사 학습
```python
class NewsPersonalization:
    def __init__(self):
        self.user_profiles = {}
        
    def learn_user_preferences(self, user_id, interactions):
        """사용자 선호도 학습"""
        if user_id not in self.user_profiles:
            self.user_profiles[user_id] = {
                'categories': defaultdict(float),
                'keywords': defaultdict(float),
                'stocks': defaultdict(float),
                'sentiment_preference': 0.5
            }
        
        profile = self.user_profiles[user_id]
        
        for interaction in interactions:
            # 클릭한 뉴스의 카테고리 가중치 증가
            if interaction['action'] == 'click':
                profile['categories'][interaction['category']] += 1.0
                
                # 키워드 추출 및 가중치 증가
                keywords = self.extract_keywords(interaction['content'])
                for keyword in keywords:
                    profile['keywords'][keyword] += 0.5
                
                # 관련 종목 가중치 증가
                for stock in interaction['related_stocks']:
                    profile['stocks'][stock] += 0.8
            
            # 체류 시간 기반 가중치
            if interaction['read_time'] > 30:  # 30초 이상 읽음
                weight_bonus = min(interaction['read_time'] / 60, 2.0)
                profile['categories'][interaction['category']] += weight_bonus
        
        return profile
```

### 2. 맞춤형 뉴스 추천
```python
class NewsRecommender:
    def __init__(self):
        self.tfidf_vectorizer = TfidfVectorizer(max_features=1000)
        
    def recommend_news(self, user_profile, news_pool, top_k=20):
        """개인화된 뉴스 추천"""
        scored_news = []
        
        for news in news_pool:
            score = 0
            
            # 카테고리 매칭 점수
            category_score = user_profile['categories'].get(
                news['category'], 0
            ) * 0.3
            
            # 키워드 매칭 점수
            keyword_score = sum(
                user_profile['keywords'].get(kw, 0) 
                for kw in news['keywords']
            ) * 0.3
            
            # 종목 관련성 점수
            stock_score = sum(
                user_profile['stocks'].get(stock['ticker'], 0)
                for stock in news['related_stocks']
            ) * 0.2
            
            # 감성 선호도 점수
            sentiment_match = 1 - abs(
                user_profile['sentiment_preference'] - 
                news['sentiment']['score']
            )
            sentiment_score = sentiment_match * 0.1
            
            # 시간 가중치 (최신 뉴스 우선)
            time_decay = self.calculate_time_decay(news['published'])
            time_score = time_decay * 0.1
            
            # 총점 계산
            total_score = (category_score + keyword_score + 
                          stock_score + sentiment_score + time_score)
            
            scored_news.append({
                'news': news,
                'score': total_score,
                'breakdown': {
                    'category': category_score,
                    'keyword': keyword_score,
                    'stock': stock_score,
                    'sentiment': sentiment_score,
                    'recency': time_score
                }
            })
        
        # 상위 K개 추천
        recommended = sorted(scored_news, 
                           key=lambda x: x['score'], 
                           reverse=True)[:top_k]
        
        return recommended
```

## 뉴스 요약 및 인사이트

### 1. AI 기반 뉴스 요약
```python
class NewsSummarizer:
    def __init__(self):
        self.summarizer = pipeline(
            "summarization",
            model="gogamza/kobart-summarization"
        )
        
    def summarize_article(self, article_text, max_length=150):
        """뉴스 기사 요약"""
        # 긴 텍스트 분할
        chunks = self.split_text(article_text, max_chunk_size=1024)
        
        # 각 청크 요약
        summaries = []
        for chunk in chunks:
            summary = self.summarizer(
                chunk,
                max_length=max_length,
                min_length=50,
                do_sample=False
            )[0]['summary_text']
            summaries.append(summary)
        
        # 요약 통합
        if len(summaries) > 1:
            final_summary = self.combine_summaries(summaries)
        else:
            final_summary = summaries[0]
        
        return {
            'summary': final_summary,
            'key_points': self.extract_key_points(article_text),
            'word_count': len(final_summary.split()),
            'compression_ratio': len(final_summary) / len(article_text)
        }
    
    def extract_key_points(self, text):
        """핵심 포인트 추출"""
        sentences = text.split('.')
        
        # TF-IDF로 중요 문장 선택
        vectorizer = TfidfVectorizer()
        tfidf_matrix = vectorizer.fit_transform(sentences)
        
        # 문장 중요도 계산
        sentence_scores = tfidf_matrix.sum(axis=1).flatten().tolist()[0]
        
        # 상위 3개 문장 선택
        top_indices = sorted(range(len(sentence_scores)), 
                           key=lambda i: sentence_scores[i], 
                           reverse=True)[:3]
        
        key_points = [sentences[i].strip() for i in sorted(top_indices)]
        
        return key_points
```

### 2. 시장 영향도 분석
```python
class MarketImpactAnalyzer:
    def __init__(self):
        self.impact_keywords = {
            'high': ['금리 인상', '기준금리', '대규모 인수', '정부 규제', 
                    '무역 전쟁', '팬데믹', '전쟁', '파산'],
            'medium': ['실적 발표', '신제품 출시', '투자 유치', '업황 개선',
                      '수주 확대', '매출 증가', '영업이익'],
            'low': ['인사 변동', '사무실 이전', '소규모 투자', '행사 개최']
        }
        
    def analyze_impact(self, news):
        """뉴스의 시장 영향도 분석"""
        text = news['title'] + " " + news['content']
        
        # 영향도 레벨 결정
        impact_level = 'low'
        for level, keywords in self.impact_keywords.items():
            if any(keyword in text for keyword in keywords):
                impact_level = level
                break
        
        # 영향 범위 분석
        affected_sectors = self.identify_affected_sectors(text)
        affected_stocks = self.identify_affected_stocks(text)
        
        # 예상 지속 기간
        duration = self.estimate_impact_duration(impact_level)
        
        # 시장 반응 예측
        market_reaction = self.predict_market_reaction(news, impact_level)
        
        return {
            'level': impact_level,
            'score': self.calculate_impact_score(impact_level),
            'affected_sectors': affected_sectors,
            'affected_stocks': affected_stocks,
            'duration': duration,
            'market_reaction': market_reaction,
            'confidence': self.calculate_confidence(news)
        }
```

## 실시간 알림 시스템

### 1. 키워드 알림
```python
class NewsAlertSystem:
    def __init__(self):
        self.user_alerts = defaultdict(list)
        
    def add_keyword_alert(self, user_id, keywords):
        """키워드 기반 알림 설정"""
        self.user_alerts[user_id].append({
            'type': 'keyword',
            'keywords': keywords,
            'created_at': datetime.now()
        })
    
    def add_stock_alert(self, user_id, tickers):
        """종목 관련 뉴스 알림"""
        self.user_alerts[user_id].append({
            'type': 'stock',
            'tickers': tickers,
            'created_at': datetime.now()
        })
    
    def check_alerts(self, news):
        """알림 조건 확인"""
        triggered_alerts = []
        
        for user_id, alerts in self.user_alerts.items():
            for alert in alerts:
                if alert['type'] == 'keyword':
                    if any(kw in news['title'] or kw in news['content'] 
                          for kw in alert['keywords']):
                        triggered_alerts.append({
                            'user_id': user_id,
                            'news': news,
                            'alert_type': 'keyword',
                            'matched': [kw for kw in alert['keywords'] 
                                       if kw in news['title'] or kw in news['content']]
                        })
                
                elif alert['type'] == 'stock':
                    mentioned_tickers = [s['ticker'] for s in news['related_stocks']]
                    if any(ticker in mentioned_tickers for ticker in alert['tickers']):
                        triggered_alerts.append({
                            'user_id': user_id,
                            'news': news,
                            'alert_type': 'stock',
                            'matched': [t for t in alert['tickers'] 
                                       if t in mentioned_tickers]
                        })
        
        return triggered_alerts
```

### 2. 푸시 알림 전송
```python
def send_push_notification(user_id, alert):
    """푸시 알림 전송"""
    notification = {
        'title': f"📰 {alert['alert_type'].upper()} 알림",
        'body': alert['news']['title'],
        'data': {
            'news_id': alert['news']['id'],
            'url': alert['news']['link'],
            'matched': alert['matched']
        }
    }
    
    # FCM 또는 웹 푸시 전송
    if user_has_mobile_token(user_id):
        send_fcm_notification(user_id, notification)
    elif user_has_web_subscription(user_id):
        send_web_push(user_id, notification)
    
    # 이메일 알림 (선택적)
    if user_wants_email(user_id):
        send_email_notification(user_id, alert)
```

## 뉴스 시각화

### 1. 감성 트렌드 차트
```javascript
// 시간대별 감성 트렌드
const sentimentTrendChart = new Chart(ctx, {
    type: 'line',
    data: {
        labels: hourlyLabels,
        datasets: [{
            label: '긍정',
            data: positiveScores,
            borderColor: 'green',
            backgroundColor: 'rgba(0,255,0,0.1)'
        }, {
            label: '부정',
            data: negativeScores,
            borderColor: 'red',
            backgroundColor: 'rgba(255,0,0,0.1)'
        }, {
            label: '중립',
            data: neutralScores,
            borderColor: 'gray',
            backgroundColor: 'rgba(128,128,128,0.1)'
        }]
    },
    options: {
        responsive: true,
        plugins: {
            title: {
                display: true,
                text: '시간대별 뉴스 감성 트렌드'
            }
        }
    }
});
```

### 2. 키워드 클라우드
```python
def generate_keyword_cloud(news_list):
    """키워드 클라우드 생성"""
    from wordcloud import WordCloud
    import matplotlib.pyplot as plt
    
    # 모든 뉴스 텍스트 결합
    all_text = ' '.join([n['title'] + ' ' + n['content'] 
                         for n in news_list])
    
    # 불용어 제거
    stopwords = load_korean_stopwords()
    
    # 워드클라우드 생성
    wordcloud = WordCloud(
        font_path='NanumGothic.ttf',
        width=800,
        height=400,
        background_color='white',
        stopwords=stopwords,
        max_words=100
    ).generate(all_text)
    
    # 이미지 저장
    plt.figure(figsize=(10, 5))
    plt.imshow(wordcloud, interpolation='bilinear')
    plt.axis('off')
    plt.tight_layout(pad=0)
    
    return wordcloud
```

## 뉴스 페이지 UI/UX

### 1. 뉴스 카드 컴포넌트
```html
<div class="news-card">
    <div class="news-header">
        <span class="news-source">한국경제</span>
        <span class="news-time">10분 전</span>
        <span class="sentiment-badge positive">긍정</span>
    </div>
    
    <h3 class="news-title">
        삼성전자, 3분기 영업이익 9.18조원...시장 예상치 상회
    </h3>
    
    <p class="news-summary">
        삼성전자가 3분기 영업이익 9조1800억원을 기록했다. 
        이는 전년 동기 대비 277% 증가한 수치로...
    </p>
    
    <div class="news-tags">
        <span class="tag">#삼성전자</span>
        <span class="tag">#반도체</span>
        <span class="tag">#실적</span>
    </div>
    
    <div class="related-stocks">
        <span class="stock-chip">
            005930 <span class="change up">+2.3%</span>
        </span>
    </div>
    
    <div class="news-actions">
        <button class="btn-read-more">자세히 보기</button>
        <button class="btn-save">저장</button>
        <button class="btn-share">공유</button>
    </div>
</div>
```

### 2. 필터링 및 정렬 옵션
```html
<div class="news-filters">
    <select id="category-filter">
        <option value="all">전체</option>
        <option value="market">시황</option>
        <option value="company">기업</option>
        <option value="economy">경제</option>
        <option value="global">해외</option>
    </select>
    
    <select id="sentiment-filter">
        <option value="all">모든 감성</option>
        <option value="positive">긍정</option>
        <option value="negative">부정</option>
        <option value="neutral">중립</option>
    </select>
    
    <input type="text" 
           id="keyword-search" 
           placeholder="키워드 검색...">
    
    <select id="sort-order">
        <option value="recent">최신순</option>
        <option value="relevant">관련도순</option>
        <option value="impact">영향도순</option>
    </select>
</div>
```

## API 엔드포인트

### 1. 뉴스 목록 조회
```python
@app.route('/api/news', methods=['GET'])
def get_news_list():
    """뉴스 목록 API"""
    # 파라미터 파싱
    category = request.args.get('category', 'all')
    sentiment = request.args.get('sentiment', 'all')
    keyword = request.args.get('keyword', '')
    page = int(request.args.get('page', 1))
    limit = int(request.args.get('limit', 20))
    
    # 필터링
    query = build_news_query(category, sentiment, keyword)
    
    # 페이지네이션
    total_count = count_news(query)
    news_list = fetch_news(query, page, limit)
    
    # 개인화 (로그인 사용자)
    if 'user_id' in session:
        news_list = personalize_news(session['user_id'], news_list)
    
    return jsonify({
        'news': news_list,
        'pagination': {
            'page': page,
            'limit': limit,
            'total': total_count,
            'pages': (total_count + limit - 1) // limit
        }
    })
```

### 2. 뉴스 감성 분석 API
```python
@app.route('/api/news/sentiment/<news_id>', methods=['GET'])
def get_news_sentiment(news_id):
    """뉴스 감성 분석 결과"""
    news = get_news_by_id(news_id)
    
    if not news:
        return jsonify({'error': 'News not found'}), 404
    
    # 감성 분석 수행
    sentiment = sentiment_analyzer.analyze(news['content'])
    
    # 관련 종목 감성 영향도
    stock_impacts = []
    for stock in news['related_stocks']:
        impact = calculate_stock_impact(stock, sentiment)
        stock_impacts.append({
            'ticker': stock['ticker'],
            'name': stock['name'],
            'impact': impact
        })
    
    return jsonify({
        'news_id': news_id,
        'sentiment': sentiment,
        'stock_impacts': stock_impacts,
        'market_impact': calculate_market_impact(sentiment),
        'confidence': sentiment['confidence']
    })
```

## 데이터 저장 구조

### 1. 뉴스 데이터베이스 스키마
```sql
CREATE TABLE news (
    id SERIAL PRIMARY KEY,
    title VARCHAR(500) NOT NULL,
    content TEXT,
    summary TEXT,
    source VARCHAR(100),
    author VARCHAR(100),
    published_at TIMESTAMP,
    url VARCHAR(500) UNIQUE,
    category VARCHAR(50),
    sentiment VARCHAR(20),
    sentiment_score FLOAT,
    importance_score FLOAT,
    view_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE news_stocks (
    news_id INTEGER REFERENCES news(id),
    ticker VARCHAR(10),
    company_name VARCHAR(100),
    mention_count INTEGER,
    sentiment_impact FLOAT,
    PRIMARY KEY (news_id, ticker)
);

CREATE TABLE news_keywords (
    id SERIAL PRIMARY KEY,
    news_id INTEGER REFERENCES news(id),
    keyword VARCHAR(50),
    tf_idf_score FLOAT
);

CREATE TABLE user_news_interactions (
    user_id VARCHAR(50),
    news_id INTEGER REFERENCES news(id),
    action VARCHAR(20),  -- view, click, save, share
    duration INTEGER,  -- reading time in seconds
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 성능 최적화

### 1. 캐싱 전략
```python
# Redis 캐싱
cache_config = {
    'news_list': 60,  # 1분
    'sentiment_analysis': 3600,  # 1시간
    'keyword_cloud': 1800,  # 30분
    'trending_topics': 300  # 5분
}

def get_cached_news(category, page):
    cache_key = f"news:{category}:{page}"
    cached = redis_client.get(cache_key)
    
    if cached:
        return json.loads(cached)
    
    # 캐시 미스 - DB에서 조회
    news = fetch_news_from_db(category, page)
    
    # 캐시 저장
    redis_client.setex(
        cache_key,
        cache_config['news_list'],
        json.dumps(news)
    )
    
    return news
```

### 2. 배치 처리
```python
def batch_process_news():
    """뉴스 배치 처리"""
    # 대량 뉴스 수집
    news_batch = collect_bulk_news()
    
    # 벡터화 (한 번에 처리)
    texts = [n['content'] for n in news_batch]
    vectors = tfidf_vectorizer.transform(texts)
    
    # 병렬 감성 분석
    with ThreadPoolExecutor(max_workers=4) as executor:
        sentiments = list(executor.map(
            analyze_sentiment, 
            news_batch
        ))
    
    # DB 일괄 삽입
    bulk_insert_news(news_batch, sentiments, vectors)
```

## 향후 개발 계획

1. **AI 고도화**
   - GPT-4 기반 뉴스 분석
   - 다국어 뉴스 지원
   - 가짜 뉴스 탐지

2. **실시간 기능 강화**
   - WebSocket 기반 실시간 피드
   - 라이브 뉴스 스트리밍
   - 속보 알림 시스템

3. **소셜 기능**
   - 뉴스 댓글 시스템
   - 사용자 간 뉴스 공유
   - 전문가 의견 통합

4. **분석 도구**
   - 뉴스 기반 예측 모델
   - 이벤트 임팩트 분석
   - 센티먼트 대시보드

5. **개인화 강화**
   - 딥러닝 기반 추천
   - 읽기 패턴 학습
   - 맞춤형 요약 생성