# 04_AI챗봇_상세.md - AI 챗봇 페이지 개발 문서

## 목차
1. [페이지 개요](#1-페이지-개요)
2. [멀티 에이전트 시스템](#2-멀티-에이전트-시스템)
3. [백엔드 구현](#3-백엔드-구현)
4. [프론트엔드 구현](#4-프론트엔드-구현)
5. [실시간 스트리밍](#5-실시간-스트리밍)
6. [상태 관리](#6-상태-관리)
7. [UI/UX 디자인](#7-uiux-디자인)
8. [에러 처리](#8-에러-처리)
9. [성능 최적화](#9-성능-최적화)
10. [보안 및 프라이버시](#10-보안-및-프라이버시)

---

## 1. 페이지 개요

### 1.1 목적
개인화된 AI 투자 상담 서비스를 제공하는 핵심 기능. 사용자의 투자 성향을 기반으로 맞춤형 투자 조언을 제공하며, 실시간 금융 데이터를 활용한 구체적인 투자 전략을 제시합니다.

### 1.2 주요 기능
- **멀티 에이전트 AI 시스템**: AI-A → AI-A2 → AI-B → Final Response 체인
- **실시간 스트리밍**: SSE(Server-Sent Events) 기반 실시간 응답
- **개인화 상담**: 투자 성향 기반 맞춤형 조언
- **금융 데이터 통합**: 실시간 주가, 뉴스, 재무제표 활용
- **대화 기록 관리**: 세션별 대화 저장 및 컨텍스트 유지

### 1.3 파일 구조
```
├── web/
│   ├── app.py                        # API 엔드포인트
│   └── templates/
│       └── chatbot.html              # 챗봇 UI
├── src/
│   ├── investment_advisor.py         # 핵심 AI 에이전트 체인
│   ├── llm_service.py               # LLM API 추상화
│   ├── memory_manager.py            # 대화 메모리 관리
│   ├── user_profile_analyzer.py     # 사용자 프로필 분석
│   └── financial_data_processor.py  # 금융 데이터 처리
└── prompts/
    ├── prompt_AI-A.txt              # AI-A 프롬프트
    ├── prompt_AI-A2.txt             # AI-A2 프롬프트
    └── prompt_AI-B.txt              # AI-B 프롬프트
```

---

## 2. 멀티 에이전트 시스템

### 2.1 에이전트 체인 아키텍처

```
사용자 입력
    │
    ▼
┌─────────────┐
│   AI-A      │ ← 투자 성향 기반 초기 응답
└─────────────┘
    │
    ▼
┌─────────────┐
│   AI-A2     │ ← 질문 명확화 및 데이터 요청
└─────────────┘
    │
    ▼
┌─────────────┐
│   AI-B      │ ← 실시간 금융 데이터 분석
└─────────────┘
    │
    ▼
┌─────────────┐
│Final Response│ ← 통합된 최종 응답
└─────────────┘
    │
    ▼
사용자에게 전달
```

### 2.2 에이전트별 역할

#### 2.2.1 AI-A (초기 응답 에이전트)
```python
# investment_advisor.py:164-203
# AI-A: 사용자 성향 기반 초기 투자 조언
ai_a_messages = [
    {"role": "system", "content": ai_a_prompt},
    {"role": "user", "content": user_input}
]

self._update_status("AI-A: 투자 성향 분석 중...")
ai_a_response = self.llm_service.chat_completion(ai_a_messages)
self.memory_manager.save_memory("AI-A", ai_a_response)
```

**역할**:
- 사용자의 투자 성향 분석
- 맞춤형 초기 조언 생성
- 투자 심리 고려

#### 2.2.2 AI-A2 (질문 명확화 에이전트)
```python
# investment_advisor.py:205-247
# AI-A2: AI-A 응답 기반 질문 명확화
ai_a2_prompt = self._prepare_ai_a2_prompt(user_profile)
ai_a2_messages = [
    {"role": "system", "content": ai_a2_prompt},
    {"role": "user", "content": f"사용자 질문: {user_input}"},
    {"role": "assistant", "content": ai_a_response},
    {"role": "user", "content": "이 답변을 바탕으로 AI-B에게 필요한 금융 정보를 물어보세요."}
]
```

**역할**:
- AI-A 응답 분석
- 구체적인 데이터 요청 생성
- AI-B와의 브릿지 역할

#### 2.2.3 AI-B (데이터 분석 에이전트)
```python
# investment_advisor.py:249-291
# AI-B: 실시간 금융 데이터 제공
ai_b_prompt = self._prepare_ai_b_prompt()
ai_b_messages = [
    {"role": "system", "content": ai_b_prompt},
    {"role": "user", "content": ai_a2_response}
]

self._update_status("AI-B: 금융 데이터 분석 중...")
ai_b_response = self.llm_service.chat_completion(ai_b_messages)
```

**역할**:
- 실시간 시장 데이터 분석
- 재무제표 및 기술적 분석
- 객관적 데이터 제공

#### 2.2.4 Final Response (통합 에이전트)
```python
# investment_advisor.py:293-341
# 최종 응답: 모든 AI 응답 통합
final_messages = [
    {"role": "system", "content": self._prepare_final_prompt(user_profile)},
    {"role": "user", "content": f"원래 질문: {user_input}"},
    {"role": "assistant", "content": f"AI-A 분석: {ai_a_response}"},
    {"role": "assistant", "content": f"AI-B 데이터: {ai_b_response}"},
    {"role": "user", "content": "위 정보를 종합하여 최종 투자 조언을 제공해주세요."}
]
```

---

## 3. 백엔드 구현

### 3.1 메인 챗봇 라우트 (`app.py:1284-1287`)

```python
@app.route('/chatbot')
def chatbot():
    """챗봇 페이지를 렌더링합니다."""
    return render_template('chatbot.html')
```

### 3.2 챗봇 API 엔드포인트 (`app.py:2272-2444`)

```python
@app.route('/api/chat', methods=['POST'])
def chat():
    """MINERVA 챗봇에 메시지를 전송하고 응답을 받습니다."""
    try:
        data = request.json
        message = data.get('message', '').strip()
        session_id = session.get('user_id')
        if not session_id:
            session_id = f"user_{str(uuid.uuid4())[:8]}"
            session['user_id'] = session_id
            
        # 1. 설문 결과 조회
        from src.db_client import get_supabase_client
        supabase = get_supabase_client()
        
        has_profile = False
        profile_json = None
        summary = None
        
        if supabase:
            try:
                res = supabase.table("user_profiles").select("profile_json,summary").eq("user_id", session_id).order("created_at", desc=True).limit(1).execute()
                has_profile = res.data and len(res.data) > 0
                profile_json = res.data[0]['profile_json'] if has_profile else None
                summary = res.data[0]['summary'] if has_profile else None
            except Exception as e:
                logger.error(f"Supabase 조회 오류: {e}")
                # SQLite 폴백 (2299-2315)
                
        # 2. 설문 미완료 시 안내
        if not has_profile:
            return jsonify({
                "success": False,
                "require_survey": True,
                "message": "먼저 투자 성향 설문을 완료해 주세요!"
            })
            
        # 3. InvestmentAdvisor 초기화
        from src.investment_advisor import InvestmentAdvisor
        from src.llm_service import get_optimal_api_type
        api_type = get_optimal_api_type()
        
        # Financial processor 초기화
        from src.financial_data_processor import FinancialDataProcessor
        financial_processor = FinancialDataProcessor()
        
        advisor = InvestmentAdvisor(api_type=api_type, financial_processor=financial_processor)
        advisor.set_session_id(session_id)
        
        # 4. 사용자 프로필 설정
        if profile_json:
            advisor.memory_manager.set_user_profile(profile_json)
            
        # 5. AI 응답 생성
        try:
            response = advisor.chat(message)
            
            # 6. 대화 기록 저장
            if supabase:
                supabase.table("chat_history").insert({
                    "user_id": session_id,
                    "message": message,
                    "response": response,
                    "created_at": datetime.now().isoformat()
                }).execute()
                
            return jsonify({
                "success": True,
                "response": response,
                "session_id": session_id
            })
            
        except Exception as e:
            logger.error(f"AI 응답 생성 실패: {e}")
            return jsonify({
                "success": False,
                "error": str(e)
            })
            
    except Exception as e:
        logger.error(f"채팅 API 오류: {e}")
        return jsonify({
            "success": False,
            "error": "채팅 처리 중 오류가 발생했습니다."
        })
```

**주요 처리 흐름**:
1. 세션 ID 확인 및 생성 (2278-2281)
2. 사용자 프로필 조회 (2283-2315)
3. 설문 완료 여부 확인 (2362-2368)
4. InvestmentAdvisor 초기화 (2371-2380)
5. AI 응답 생성 (2390-2391)
6. 대화 기록 저장 (2394-2400)

### 3.3 스트리밍 API (`app.py:3934-4080`)

```python
@app.route('/api/chat-stream')
def chat_stream():
    """SSE (Server-Sent Events) 형식으로 AI 응답을 스트리밍합니다."""
    from flask import Response, stream_with_context
    
    message = request.args.get('message', '').strip()
    session_id = session.get('user_id')
    if not session_id:
        session_id = f"user_{str(uuid.uuid4())[:8]}"
        session['user_id'] = session_id
    
    def generate():
        try:
            # 1. 프로필 확인
            has_profile = check_user_profile(session_id)
            
            if not has_profile:
                yield f"data: {json.dumps({'content': '먼저 투자 성향 설문을 완료해 주세요!', 'require_survey': True})}\n\n"
                yield "event: complete\ndata: {}\n\n"
                return
                
            # 2. InvestmentAdvisor 초기화
            advisor = InvestmentAdvisor(api_type=api_type, financial_processor=financial_processor)
            advisor.set_session_id(session_id)
            
            # 3. 콜백 설정
            def status_callback(agent, status):
                yield f"event: status\ndata: {json.dumps({'agent': agent, 'status': status})}\n\n"
                
            def response_callback(agent, response):
                yield f"event: agent\ndata: {json.dumps({'agent': agent, 'response': response})}\n\n"
                
            advisor.set_status_callback(status_callback)
            advisor.set_response_callback(response_callback)
            
            # 4. 스트리밍 응답 생성
            response = advisor.chat(message)
            
            # 5. 최종 응답 전송
            yield f"data: {json.dumps({'content': response})}\n\n"
            yield "event: complete\ndata: {}\n\n"
            
        except Exception as e:
            yield f"event: error\ndata: {json.dumps({'error': str(e)})}\n\n"
    
    return Response(
        stream_with_context(generate()),
        mimetype="text/event-stream",
        headers={
            'Cache-Control': 'no-cache',
            'X-Accel-Buffering': 'no'
        }
    )
```

**SSE 이벤트 타입**:
- `status`: 에이전트 상태 업데이트
- `agent`: 에이전트별 응답
- `data`: 최종 응답 콘텐츠
- `complete`: 스트리밍 완료
- `error`: 오류 발생

---

## 4. 프론트엔드 구현

### 4.1 HTML 구조 (`chatbot.html`)

#### 4.1.1 채팅 컨테이너 (8-28줄)
```html
<div class="pixie-chatbot-container">
    <div class="pixie-chat-wrapper">
        <!-- 헤더 -->
        <div class="pixie-chat-header">
            <div class="pixie-chat-avatar">🤖</div>
            <div class="pixie-chat-info">
                <h2>Pixie AI 투자 어드바이저</h2>
                <p>맞춤형 투자 조언을 제공합니다</p>
            </div>
            <button class="pixie-chat-close" onclick="window.history.back()">
                <i class="bi bi-x-lg"></i>
            </button>
        </div>
        
        <!-- 메시지 영역 -->
        <div class="pixie-chat-messages" id="chatMessages">
            <!-- 동적으로 메시지 추가 -->
        </div>
        
        <!-- 입력 영역 -->
        <div class="pixie-chat-input-container">
            <input type="text" class="pixie-chat-input" id="chatInput" 
                   placeholder="투자에 대해 궁금한 점을 물어보세요...">
            <button class="pixie-chat-send" id="sendButton">
                <i class="bi bi-send-fill"></i>
            </button>
        </div>
    </div>
</div>
```

#### 4.1.2 메시지 스타일 (110-221줄)
```css
/* 사용자 메시지 */
.pixie-message-user {
    background: var(--gradient-primary);
    color: white;
    padding: 16px 20px;
    border-radius: 20px 20px 4px 20px;
    margin-left: auto;
    box-shadow: var(--shadow-sm);
}

/* AI 메시지 */
.pixie-message-ai {
    background: white;
    color: var(--text-primary);
    padding: 16px 20px;
    border-radius: 20px 20px 20px 4px;
    box-shadow: var(--shadow-sm);
    border: 1px solid var(--border-color);
}

/* 에이전트별 메시지 스타일 */
.pixie-message-agent {
    background: #f0f7ff;
    border: 1px solid #cce5ff;
}

.pixie-message-agent.agent-a2 {
    background: #fff5e6;
    border-color: #ffd6a5;
}

.pixie-message-agent.agent-b {
    background: #e6f9f5;
    border-color: #a5e5d6;
}

/* 에이전트 라벨 */
.agent-label {
    font-weight: 700;
    color: #1454FE;
    font-size: 13px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.agent-label .agent-icon {
    width: 20px;
    height: 20px;
    background: #1454FE;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    font-weight: 900;
}
```

### 4.2 JavaScript 구현

#### 4.2.1 ChatbotManager 클래스
```javascript
class ChatbotManager {
    constructor() {
        this.messageContainer = document.getElementById('chatMessages');
        this.inputField = document.getElementById('chatInput');
        this.sendButton = document.getElementById('sendButton');
        this.isProcessing = false;
        this.eventSource = null;
        this.currentAgentMessages = {};
        
        this.init();
    }
    
    init() {
        // 이벤트 리스너 설정
        this.sendButton.addEventListener('click', () => this.sendMessage());
        this.inputField.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !this.isProcessing) {
                this.sendMessage();
            }
        });
        
        // 초기 메시지 표시
        this.showWelcomeMessage();
        
        // 세션 복구
        this.loadChatHistory();
    }
    
    showWelcomeMessage() {
        const welcomeMsg = `안녕하세요! 저는 Pixie AI 투자 어드바이저입니다. 
        투자에 관한 궁금한 점을 편하게 물어보세요. 😊`;
        this.addMessage(welcomeMsg, 'ai');
    }
    
    async sendMessage() {
        const message = this.inputField.value.trim();
        if (!message || this.isProcessing) return;
        
        this.isProcessing = true;
        this.inputField.value = '';
        this.inputField.disabled = true;
        this.sendButton.disabled = true;
        
        // 사용자 메시지 표시
        this.addMessage(message, 'user');
        
        // 타이핑 인디케이터 표시
        this.showTypingIndicator();
        
        try {
            // SSE 연결 시작
            await this.startStreaming(message);
        } catch (error) {
            console.error('메시지 전송 실패:', error);
            this.showError('메시지 전송 중 오류가 발생했습니다.');
        } finally {
            this.isProcessing = false;
            this.inputField.disabled = false;
            this.sendButton.disabled = false;
            this.inputField.focus();
        }
    }
    
    async startStreaming(message) {
        const url = `/api/chat-stream?message=${encodeURIComponent(message)}`;
        
        this.eventSource = new EventSource(url);
        
        this.eventSource.addEventListener('status', (event) => {
            const data = JSON.parse(event.data);
            this.updateAgentStatus(data.agent, data.status);
        });
        
        this.eventSource.addEventListener('agent', (event) => {
            const data = JSON.parse(event.data);
            this.showAgentMessage(data.agent, data.response);
        });
        
        this.eventSource.addEventListener('message', (event) => {
            const data = JSON.parse(event.data);
            if (data.content) {
                this.hideTypingIndicator();
                this.addMessage(data.content, 'ai');
            }
            if (data.require_survey) {
                this.showSurveyPrompt();
            }
        });
        
        this.eventSource.addEventListener('complete', () => {
            this.eventSource.close();
            this.hideTypingIndicator();
            this.saveChatHistory();
        });
        
        this.eventSource.addEventListener('error', (event) => {
            console.error('SSE 오류:', event);
            this.eventSource.close();
            this.hideTypingIndicator();
            this.showError('연결이 끊어졌습니다.');
        });
    }
    
    addMessage(content, type) {
        const messageDiv = document.createElement('div');
        messageDiv.className = `pixie-message pixie-message-${type}`;
        
        if (type === 'ai') {
            messageDiv.innerHTML = `
                <div class="message-content">
                    ${this.formatMessage(content)}
                </div>
                <div class="message-time">${this.getCurrentTime()}</div>
            `;
        } else {
            messageDiv.innerHTML = `
                <div class="message-content">${this.escapeHtml(content)}</div>
                <div class="message-time">${this.getCurrentTime()}</div>
            `;
        }
        
        this.messageContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    showAgentMessage(agent, response) {
        // 에이전트별 메시지 표시
        const agentConfig = {
            'AI-A': { class: 'agent-a', label: 'AI-A', icon: 'A' },
            'AI-A2': { class: 'agent-a2', label: 'AI-A2', icon: 'A2' },
            'AI-B': { class: 'agent-b', label: 'AI-B', icon: 'B' }
        };
        
        const config = agentConfig[agent] || { class: '', label: agent, icon: '?' };
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `pixie-message pixie-message-agent ${config.class}`;
        messageDiv.innerHTML = `
            <div class="agent-label">
                <span class="agent-icon">${config.icon}</span>
                ${config.label}
            </div>
            <div class="message-content">
                ${this.formatMessage(response)}
            </div>
        `;
        
        this.messageContainer.appendChild(messageDiv);
        this.scrollToBottom();
    }
    
    updateAgentStatus(agent, status) {
        // 상태 표시 (예: "AI-A가 분석 중...")
        const statusDiv = document.getElementById(`status-${agent}`);
        if (statusDiv) {
            statusDiv.textContent = `${agent}: ${status}`;
        }
    }
    
    showTypingIndicator() {
        const indicator = document.createElement('div');
        indicator.className = 'pixie-typing-indicator';
        indicator.id = 'typingIndicator';
        indicator.innerHTML = `
            <div class="pixie-typing-dot"></div>
            <div class="pixie-typing-dot"></div>
            <div class="pixie-typing-dot"></div>
        `;
        this.messageContainer.appendChild(indicator);
        this.scrollToBottom();
    }
    
    hideTypingIndicator() {
        const indicator = document.getElementById('typingIndicator');
        if (indicator) {
            indicator.remove();
        }
    }
    
    formatMessage(content) {
        // 마크다운 형식 변환
        return content
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/\n/g, '<br>')
            .replace(/```(.*?)```/gs, '<pre><code>$1</code></pre>')
            .replace(/`(.*?)`/g, '<code>$1</code>');
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    getCurrentTime() {
        return new Date().toLocaleTimeString('ko-KR', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }
    
    scrollToBottom() {
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
    }
    
    showSurveyPrompt() {
        const promptDiv = document.createElement('div');
        promptDiv.className = 'survey-prompt';
        promptDiv.innerHTML = `
            <p>투자 성향 분석이 필요합니다.</p>
            <a href="/survey" class="btn btn-primary">설문 시작하기</a>
        `;
        this.messageContainer.appendChild(promptDiv);
        this.scrollToBottom();
    }
    
    showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        this.messageContainer.appendChild(errorDiv);
        this.scrollToBottom();
        
        setTimeout(() => {
            errorDiv.remove();
        }, 5000);
    }
    
    async loadChatHistory() {
        try {
            const response = await fetch('/api/chat-history');
            const data = await response.json();
            
            if (data.success && data.history) {
                data.history.forEach(item => {
                    this.addMessage(item.message, 'user');
                    this.addMessage(item.response, 'ai');
                });
            }
        } catch (error) {
            console.error('대화 기록 로드 실패:', error);
        }
    }
    
    saveChatHistory() {
        // 로컬 스토리지에 임시 저장
        const messages = Array.from(this.messageContainer.children)
            .filter(el => el.classList.contains('pixie-message'))
            .map(el => ({
                type: el.classList.contains('pixie-message-user') ? 'user' : 'ai',
                content: el.querySelector('.message-content').textContent,
                time: el.querySelector('.message-time')?.textContent
            }));
            
        localStorage.setItem('pixie_chat_history', JSON.stringify(messages));
    }
}

// 페이지 로드 시 초기화
document.addEventListener('DOMContentLoaded', () => {
    window.chatbotManager = new ChatbotManager();
});
```

---

## 5. 실시간 스트리밍

### 5.1 Server-Sent Events (SSE)

#### 5.1.1 서버 구현
```python
def generate():
    """SSE 스트림 생성기"""
    try:
        # 상태 업데이트 전송
        yield f"event: status\ndata: {json.dumps({'agent': 'AI-A', 'status': 'thinking'})}\n\n"
        
        # 에이전트 응답 전송
        yield f"event: agent\ndata: {json.dumps({'agent': 'AI-A', 'response': ai_a_response})}\n\n"
        
        # 최종 응답 전송
        yield f"data: {json.dumps({'content': final_response})}\n\n"
        
        # 완료 이벤트
        yield "event: complete\ndata: {}\n\n"
        
    except Exception as e:
        yield f"event: error\ndata: {json.dumps({'error': str(e)})}\n\n"
```

#### 5.1.2 클라이언트 구현
```javascript
const eventSource = new EventSource(url);

// 상태 업데이트 처리
eventSource.addEventListener('status', (event) => {
    const data = JSON.parse(event.data);
    updateStatusIndicator(data.agent, data.status);
});

// 에이전트 응답 처리
eventSource.addEventListener('agent', (event) => {
    const data = JSON.parse(event.data);
    displayAgentResponse(data.agent, data.response);
});

// 최종 응답 처리
eventSource.addEventListener('message', (event) => {
    const data = JSON.parse(event.data);
    displayFinalResponse(data.content);
});

// 완료 처리
eventSource.addEventListener('complete', () => {
    eventSource.close();
    enableUserInput();
});
```

### 5.2 상태 표시 UI

```html
<div class="agent-status-panel">
    <div class="agent-status" id="status-AI-A">
        <span class="status-icon">⚪</span>
        <span class="status-text">AI-A: 대기 중</span>
    </div>
    <div class="agent-status" id="status-AI-A2">
        <span class="status-icon">⚪</span>
        <span class="status-text">AI-A2: 대기 중</span>
    </div>
    <div class="agent-status" id="status-AI-B">
        <span class="status-icon">⚪</span>
        <span class="status-text">AI-B: 대기 중</span>
    </div>
</div>
```

```css
.agent-status {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: #f5f5f5;
    border-radius: 8px;
    margin-bottom: 8px;
}

.status-icon {
    font-size: 12px;
}

.agent-status.active .status-icon {
    color: #00a884;
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}
```

---

## 6. 상태 관리

### 6.1 세션 관리

```python
# 세션 ID 생성 및 관리 (app.py:2278-2281)
session_id = session.get('user_id')
if not session_id:
    session_id = f"user_{str(uuid.uuid4())[:8]}"
    session['user_id'] = session_id
```

### 6.2 메모리 관리 (`memory_manager.py`)

```python
class MemoryManager:
    """대화 컨텍스트 및 사용자 프로필 관리"""
    
    def __init__(self):
        self.conversations = []
        self.user_profile = None
        self.ai_conversations = []  # AI 간 대화
        self.session_data = {}
        
    def save_memory(self, role: str, content: str) -> None:
        """대화 메모리 저장"""
        self.conversations.append({
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat()
        })
        
        # 메모리 크기 제한 (최근 20개)
        if len(self.conversations) > 20:
            self.conversations = self.conversations[-20:]
    
    def get_conversation_context(self, limit: int = 5) -> List[Dict]:
        """최근 대화 컨텍스트 반환"""
        return self.conversations[-limit:] if self.conversations else []
    
    def set_user_profile(self, profile: Dict[str, Any]) -> None:
        """사용자 프로필 설정"""
        self.user_profile = profile
        logger.info(f"User profile set: {profile.get('investor_type', 'Unknown')}")
    
    def clear_ai_conversations(self) -> None:
        """AI 간 대화 초기화"""
        self.ai_conversations = []
```

### 6.3 대화 기록 저장

```python
# Supabase에 대화 저장 (app.py:2394-2400)
if supabase:
    supabase.table("chat_history").insert({
        "user_id": session_id,
        "message": message,
        "response": response,
        "created_at": datetime.now().isoformat()
    }).execute()
```

---

## 7. UI/UX 디자인

### 7.1 반응형 디자인

```css
/* 모바일 대응 */
@media (max-width: 768px) {
    .pixie-chatbot-container {
        padding: 0;
    }
    
    .pixie-chat-wrapper {
        height: 100vh;
        max-height: 100vh;
        border-radius: 0;
    }
    
    .pixie-message {
        max-width: 85%;
    }
    
    .pixie-chat-input {
        font-size: 16px; /* iOS 줌 방지 */
    }
}

/* 다크모드 지원 */
@media (prefers-color-scheme: dark) {
    .pixie-chat-wrapper {
        background: #1a1a1a;
        border-color: #333;
    }
    
    .pixie-chat-messages {
        background: #0d0d0d;
    }
    
    .pixie-message-ai {
        background: #2a2a2a;
        color: #e0e0e0;
    }
}
```

### 7.2 접근성 개선

```html
<!-- ARIA 레이블 -->
<div class="pixie-chat-wrapper" role="main" aria-label="AI 챗봇 대화창">
    <div class="pixie-chat-messages" role="log" aria-live="polite" aria-label="대화 내용">
        <!-- 메시지들 -->
    </div>
    
    <div class="pixie-chat-input-container">
        <input type="text" 
               class="pixie-chat-input" 
               id="chatInput"
               aria-label="메시지 입력"
               placeholder="투자에 대해 궁금한 점을 물어보세요...">
        <button class="pixie-chat-send" 
                id="sendButton"
                aria-label="메시지 전송">
            <i class="bi bi-send-fill" aria-hidden="true"></i>
        </button>
    </div>
</div>
```

### 7.3 애니메이션 효과

```css
/* 메시지 등장 애니메이션 */
@keyframes pixieMessageSlide {
    from { 
        opacity: 0; 
        transform: translateY(10px); 
    }
    to { 
        opacity: 1; 
        transform: translateY(0); 
    }
}

/* 타이핑 인디케이터 */
@keyframes pixieTyping {
    0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
    }
    40% {
        transform: scale(1);
        opacity: 1;
    }
}

/* 에이전트 전환 효과 */
.agent-transition {
    animation: agentSwitch 0.5s ease;
}

@keyframes agentSwitch {
    0% { opacity: 0; transform: translateX(-20px); }
    100% { opacity: 1; transform: translateX(0); }
}
```

---

## 8. 에러 처리

### 8.1 백엔드 에러 처리

```python
# investment_advisor.py:95-161
def chat(self, user_input: str) -> str:
    """메인 챗봇 함수 with comprehensive error handling"""
    try:
        # 세션 ID 확인
        if not self.session_id:
            return "세션 ID가 설정되지 않았습니다. 다시 시도해주세요."
            
        # 사용자 프로필 로드
        user_profile = self._load_user_profile()
        if not user_profile:
            return "투자 성향 분석이 필요합니다. 먼저 설문을 완료해주세요."
            
        # AI 체인 실행
        try:
            # AI-A 실행
            ai_a_response = self._execute_ai_a(user_input, user_profile)
        except Exception as e:
            logger.error(f"AI-A 실행 실패: {e}")
            return self._get_fallback_response("initial", user_input)
            
        try:
            # AI-A2 실행
            ai_a2_response = self._execute_ai_a2(user_input, ai_a_response, user_profile)
        except Exception as e:
            logger.error(f"AI-A2 실행 실패: {e}")
            # AI-A 응답만으로 진행
            return self._format_single_agent_response(ai_a_response)
            
        try:
            # AI-B 실행
            ai_b_response = self._execute_ai_b(ai_a2_response)
        except Exception as e:
            logger.error(f"AI-B 실행 실패: {e}")
            # AI-A와 AI-A2 응답으로 최종 응답 생성
            return self._generate_response_without_data(ai_a_response, ai_a2_response)
            
        # 최종 응답 생성
        return self._generate_final_response(user_input, ai_a_response, ai_b_response, user_profile)
        
    except Exception as e:
        logger.error(f"치명적 오류: {e}")
        return "죄송합니다. 일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요."
```

### 8.2 프론트엔드 에러 처리

```javascript
class ErrorHandler {
    constructor() {
        this.retryCount = 0;
        this.maxRetries = 3;
    }
    
    async handleApiError(error, retryFunc) {
        console.error('API 오류:', error);
        
        // 네트워크 오류
        if (!navigator.onLine) {
            this.showError('인터넷 연결을 확인해주세요.');
            return null;
        }
        
        // 401: 인증 오류
        if (error.status === 401) {
            this.showError('로그인이 필요합니다.');
            window.location.href = '/login';
            return null;
        }
        
        // 429: Rate limiting
        if (error.status === 429) {
            this.showError('요청이 너무 많습니다. 잠시 후 다시 시도해주세요.');
            return null;
        }
        
        // 500: 서버 오류 - 재시도
        if (error.status >= 500 && this.retryCount < this.maxRetries) {
            this.retryCount++;
            await this.delay(1000 * this.retryCount); // 지수 백오프
            return retryFunc();
        }
        
        // 기타 오류
        this.showError('일시적인 오류가 발생했습니다.');
        return null;
    }
    
    showError(message) {
        const errorToast = document.createElement('div');
        errorToast.className = 'error-toast';
        errorToast.innerHTML = `
            <i class="bi bi-exclamation-circle"></i>
            <span>${message}</span>
        `;
        document.body.appendChild(errorToast);
        
        setTimeout(() => {
            errorToast.classList.add('show');
        }, 100);
        
        setTimeout(() => {
            errorToast.classList.remove('show');
            setTimeout(() => errorToast.remove(), 300);
        }, 5000);
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
```

### 8.3 폴백 메커니즘

```python
# investment_advisor.py
def _get_fallback_response(self, stage: str, user_input: str) -> str:
    """단계별 폴백 응답 생성"""
    fallback_responses = {
        'initial': """
투자에 관한 질문 감사합니다. 현재 시스템에 일시적인 문제가 있어 
상세한 분석을 제공하기 어렵습니다.

일반적인 투자 원칙:
1. 분산 투자를 통한 위험 관리
2. 장기적 관점의 투자
3. 본인의 위험 감수 수준 고려
4. 정기적인 포트폴리오 리밸런싱

더 구체적인 조언이 필요하시면 잠시 후 다시 문의해주세요.
""",
        'data_unavailable': """
현재 실시간 시장 데이터를 가져올 수 없습니다.
하지만 귀하의 투자 성향을 바탕으로 일반적인 조언을 드리겠습니다.

[투자 성향 기반 일반 조언 제공]
""",
        'partial': """
일부 정보만 이용 가능한 상태입니다.
제한된 정보로 최선의 조언을 드리겠습니다.

[이용 가능한 정보 기반 조언]
"""
    }
    
    return fallback_responses.get(stage, "죄송합니다. 응답을 생성할 수 없습니다.")
```

---

## 9. 성능 최적화

### 9.1 응답 캐싱

```python
from functools import lru_cache
import hashlib

class ResponseCache:
    def __init__(self, max_size=100, ttl=3600):
        self.cache = {}
        self.max_size = max_size
        self.ttl = ttl
        
    def get_cache_key(self, user_input: str, user_profile: dict) -> str:
        """캐시 키 생성"""
        profile_str = json.dumps(user_profile, sort_keys=True)
        combined = f"{user_input}:{profile_str}"
        return hashlib.md5(combined.encode()).hexdigest()
        
    def get(self, key: str) -> Optional[str]:
        """캐시에서 응답 조회"""
        if key in self.cache:
            entry = self.cache[key]
            if time.time() - entry['timestamp'] < self.ttl:
                return entry['response']
            else:
                del self.cache[key]
        return None
        
    def set(self, key: str, response: str) -> None:
        """캐시에 응답 저장"""
        if len(self.cache) >= self.max_size:
            # LRU 제거
            oldest_key = min(self.cache.keys(), 
                           key=lambda k: self.cache[k]['timestamp'])
            del self.cache[oldest_key]
            
        self.cache[key] = {
            'response': response,
            'timestamp': time.time()
        }
```

### 9.2 병렬 처리

```python
import asyncio
from concurrent.futures import ThreadPoolExecutor

class ParallelAdvisor:
    def __init__(self):
        self.executor = ThreadPoolExecutor(max_workers=3)
        
    async def process_parallel_agents(self, user_input, user_profile):
        """AI-A와 데이터 수집을 병렬 처리"""
        loop = asyncio.get_event_loop()
        
        # 병렬 실행
        tasks = [
            loop.run_in_executor(self.executor, self._run_ai_a, user_input, user_profile),
            loop.run_in_executor(self.executor, self._collect_market_data, user_input),
            loop.run_in_executor(self.executor, self._analyze_news_sentiment)
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 결과 처리
        ai_a_response = results[0] if not isinstance(results[0], Exception) else None
        market_data = results[1] if not isinstance(results[1], Exception) else {}
        news_sentiment = results[2] if not isinstance(results[2], Exception) else {}
        
        return ai_a_response, market_data, news_sentiment
```

### 9.3 스트리밍 최적화

```javascript
class StreamOptimizer {
    constructor() {
        this.buffer = [];
        this.flushInterval = 100; // 100ms
        this.flushTimer = null;
    }
    
    addChunk(chunk) {
        this.buffer.push(chunk);
        
        if (!this.flushTimer) {
            this.flushTimer = setTimeout(() => this.flush(), this.flushInterval);
        }
    }
    
    flush() {
        if (this.buffer.length === 0) return;
        
        // 버퍼 내용을 한 번에 렌더링
        const content = this.buffer.join('');
        this.renderContent(content);
        
        this.buffer = [];
        this.flushTimer = null;
    }
    
    renderContent(content) {
        // DOM 업데이트 최소화
        requestAnimationFrame(() => {
            const messageEl = document.getElementById('currentMessage');
            if (messageEl) {
                messageEl.innerHTML += this.formatContent(content);
            }
        });
    }
}
```

---

## 10. 보안 및 프라이버시

### 10.1 입력 검증

```python
import re
from typing import Optional

class InputValidator:
    """사용자 입력 검증"""
    
    @staticmethod
    def validate_message(message: str) -> tuple[bool, Optional[str]]:
        """메시지 유효성 검증"""
        # 길이 검사
        if len(message) > 1000:
            return False, "메시지가 너무 깁니다. (최대 1000자)"
            
        # 악성 패턴 검사
        malicious_patterns = [
            r'<script.*?>.*?</script>',
            r'javascript:',
            r'on\w+\s*=',
            r'eval\s*\(',
            r'exec\s*\('
        ]
        
        for pattern in malicious_patterns:
            if re.search(pattern, message, re.IGNORECASE):
                return False, "허용되지 않는 문자가 포함되어 있습니다."
                
        # SQL 인젝션 방지
        sql_keywords = ['DROP', 'DELETE', 'INSERT', 'UPDATE', 'UNION']
        message_upper = message.upper()
        for keyword in sql_keywords:
            if keyword in message_upper:
                return False, "허용되지 않는 키워드가 포함되어 있습니다."
                
        return True, None
```

### 10.2 데이터 암호화

```python
from cryptography.fernet import Fernet
import base64

class DataEncryption:
    """민감한 데이터 암호화"""
    
    def __init__(self, key: Optional[str] = None):
        if key:
            self.cipher = Fernet(key.encode())
        else:
            self.cipher = Fernet(Fernet.generate_key())
            
    def encrypt_profile(self, profile: dict) -> str:
        """사용자 프로필 암호화"""
        profile_json = json.dumps(profile)
        encrypted = self.cipher.encrypt(profile_json.encode())
        return base64.b64encode(encrypted).decode()
        
    def decrypt_profile(self, encrypted_data: str) -> dict:
        """사용자 프로필 복호화"""
        try:
            decoded = base64.b64decode(encrypted_data.encode())
            decrypted = self.cipher.decrypt(decoded)
            return json.loads(decrypted.decode())
        except Exception as e:
            logger.error(f"복호화 실패: {e}")
            return {}
```

### 10.3 세션 보안

```python
# Flask 세션 설정
app.config.update(
    SECRET_KEY=os.environ.get('FLASK_SECRET_KEY', 'change-this-in-production'),
    SESSION_COOKIE_SECURE=True,  # HTTPS only
    SESSION_COOKIE_HTTPONLY=True,  # JavaScript 접근 차단
    SESSION_COOKIE_SAMESITE='Lax',  # CSRF 방지
    PERMANENT_SESSION_LIFETIME=timedelta(hours=2)  # 2시간 만료
)

# 세션 검증 데코레이터
def require_session(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if 'user_id' not in session:
            return jsonify({'error': 'Session required'}), 401
        return f(*args, **kwargs)
    return decorated_function
```

### 10.4 Rate Limiting

```python
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

# Rate limiter 설정
limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

# 챗봇 API에 rate limiting 적용
@app.route('/api/chat', methods=['POST'])
@limiter.limit("1 per second")  # 초당 1회
@limiter.limit("30 per minute")  # 분당 30회
@limiter.limit("500 per day")    # 일당 500회
def chat():
    # ... 챗봇 로직
```

---

## 마무리

AI 챗봇 페이지는 Pixie 서비스의 핵심 기능으로, 멀티 에이전트 AI 시스템을 통해 개인화된 투자 조언을 제공합니다. 주요 특징은:

1. **멀티 에이전트 아키텍처**: AI-A → AI-A2 → AI-B → Final Response의 체계적인 처리
2. **실시간 스트리밍**: SSE를 통한 부드러운 사용자 경험
3. **강력한 에러 처리**: 각 단계별 폴백 메커니즘
4. **보안 및 프라이버시**: 입력 검증, 데이터 암호화, rate limiting
5. **성능 최적화**: 캐싱, 병렬 처리, 스트리밍 최적화

이 문서는 AI 챗봇 페이지의 전체 구현을 상세히 다루며, 향후 유지보수와 확장을 위한 기술적 참고 자료로 활용될 수 있습니다.